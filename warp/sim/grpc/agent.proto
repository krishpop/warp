syntax = "proto3";

package agent;

message Model {
  optional string xml = 2;
}

message State {
  optional double time = 1;
  repeated double joint_q = 2 [packed = true];
  repeated double joint_qd = 3 [packed = true];
  repeated double body_q = 4 [packed = true];
  repeated double body_qd = 5 [packed = true];
  repeated double joint_act = 6 [packed = true];
  repeated double body_f = 7 [packed = true];
  repeated double userdata = 8 [packed = true];
}


message InitRequest {
  optional string task_id = 1;
  Model model = 2;
  float dt = 3;
}
message InitResponse {
    string message = 1;
}


message GetStateRequest {}
message GetStateResponse {
  State state = 1;
}

message SetStateRequest {
  State state = 1;
}
message SetStateResponse {}

// message GetActionRequest {
//   // The time at which the plan should be evaluated, in seconds. If not set, the
//   // current time (from the last call to SetState) will be used.
//   // Note: for feedback controllers like iLQG, it's probably wrong to request
//   // the action in a future time, and instead the state should be set before
//   // calling GetAction.
//   optional float time = 1;

//   // If not zero, physics will be rolled out for the given duration (in seconds)
//   // and actions will be averaged over that period.
//   // During the rollout, the task's Transition will not be called.
//   optional float averaging_duration = 2;

//   // For planners that use feedback terms (iLQG), if true, return the nominal
//   // action for the given time rather than applying feedback terms on the
//   // current state. For the sampling planner this has no effect.
//   optional bool nominal_action = 3;
// }

// message GetActionResponse {
//   repeated float action = 1 [packed = true];
// }

// message GetCostValuesAndWeightsRequest {}

// message ValueAndWeight {
//   double value = 1;
//   double weight = 2;
// }

// message GetCostValuesAndWeightsResponse {
//   map<string, ValueAndWeight> values_weights = 1;
// }

// message PlannerStepRequest {}
// message PlannerStepResponse {}

message StepRequest {
  // if true, the policy from before the last call to PlanIteration will be
  // used. This is useful for simulating planning delay.
//   bool use_previous_policy = 1;
}
message StepResponse {}

message ResetRequest {}
message ResetResponse {}


service Agent {
  // Initialize MJPC Agent.
  rpc Init(InitRequest) returns (InitResponse);
  // Get the simulation state.
  rpc GetState(GetStateRequest) returns (GetStateResponse);
  // Set state of the MJPC Agent.
  rpc SetState(SetStateRequest) returns (SetStateResponse);
  // Get the current action from the Agent.
//   rpc GetAction(GetActionRequest) returns (GetActionResponse);
  // Compute one plan step.
//   rpc PlannerStep(PlannerStepRequest) returns (PlannerStepResponse);
  // Step physics once, using actions from the planner.
  rpc Step(StepRequest) returns (StepResponse);
  // Reset the Agent.
  rpc Reset(ResetRequest) returns (ResetResponse);
//   // Set a task parameters.
//   rpc SetTaskParameters(SetTaskParametersRequest)
//       returns (SetTaskParametersResponse);
//   // Get a task parameters.
//   rpc GetTaskParameters(GetTaskParametersRequest)
//       returns (GetTaskParametersResponse);
  // Set cost weights.
//   rpc SetCostWeights(SetCostWeightsRequest) returns (SetCostWeightsResponse);
//   // Get cost term values.
//   rpc GetCostValuesAndWeights(GetCostValuesAndWeightsRequest)
//       returns (GetCostValuesAndWeightsResponse);
//   // Set mode.
//   rpc SetMode(SetModeRequest) returns (SetModeResponse);
//   // Get mode.
//   rpc GetMode(GetModeRequest) returns (GetModeResponse);
//   // Get all modes.
//   rpc GetAllModes(GetAllModesRequest) returns (GetAllModesResponse);

//   // Get best trajectory (states, actions, times).
//   rpc GetBestTrajectory(GetBestTrajectoryRequest)
//       returns (GetBestTrajectoryResponse);

//   // A single method that can set many of the inputs.
//   rpc SetAnything(SetAnythingRequest) returns (SetAnythingResponse);
}