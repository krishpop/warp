..
   Autogenerated File - Do not edit. Run build_docs.py to generate.

.. functions:
.. currentmodule:: warp

Kernel Reference
================
Scalar Types
------------
.. autoclass:: int8
.. autoclass:: uint8
.. autoclass:: int16
.. autoclass:: uint16
.. autoclass:: int32
.. autoclass:: uint32
.. autoclass:: int64
.. autoclass:: uint64
.. autoclass:: float16
.. autoclass:: float32
.. autoclass:: float64
Vector Types
------------
.. autoclass:: vec2ub
.. autoclass:: vec2h
.. autoclass:: vec2f
.. autoclass:: vec2d
.. autoclass:: vec2
.. autoclass:: vec3ub
.. autoclass:: vec3h
.. autoclass:: vec3f
.. autoclass:: vec3d
.. autoclass:: vec3
.. autoclass:: vec4ub
.. autoclass:: vec4h
.. autoclass:: vec4f
.. autoclass:: vec4d
.. autoclass:: vec4
.. autoclass:: mat22h
.. autoclass:: mat22f
.. autoclass:: mat22d
.. autoclass:: mat22
.. autoclass:: mat33h
.. autoclass:: mat33f
.. autoclass:: mat33d
.. autoclass:: mat33
.. autoclass:: mat44h
.. autoclass:: mat44f
.. autoclass:: mat44d
.. autoclass:: mat44
.. autoclass:: quath
.. autoclass:: quatf
.. autoclass:: quatd
.. autoclass:: quat
.. autoclass:: transformh
.. autoclass:: transformf
.. autoclass:: transformd
.. autoclass:: transform
.. autoclass:: spatial_vectorh
.. autoclass:: spatial_vectorf
.. autoclass:: spatial_vectord
.. autoclass:: spatial_vector
.. autoclass:: spatial_matrixh
.. autoclass:: spatial_matrixf
.. autoclass:: spatial_matrixd
.. autoclass:: spatial_matrix


Scalar Math
---------------
.. function:: min(x: uint32, y: uint32) -> uint32

   Return the minimum of two scalars.


.. function:: min(x: int16, y: int16) -> int16

   Return the minimum of two scalars.


.. function:: min(x: float64, y: float64) -> float64

   Return the minimum of two scalars.


.. function:: min(x: int8, y: int8) -> int8

   Return the minimum of two scalars.


.. function:: min(x: float16, y: float16) -> float16

   Return the minimum of two scalars.


.. function:: min(x: uint16, y: uint16) -> uint16

   Return the minimum of two scalars.


.. function:: min(x: int32, y: int32) -> int32

   Return the minimum of two scalars.


.. function:: min(x: uint64, y: uint64) -> uint64

   Return the minimum of two scalars.


.. function:: min(x: float32, y: float32) -> float32

   Return the minimum of two scalars.


.. function:: min(x: int64, y: int64) -> int64

   Return the minimum of two scalars.


.. function:: min(x: uint8, y: uint8) -> uint8

   Return the minimum of two scalars.


.. function:: min(x: Scalar, y: Scalar) -> Scalar

   Return the minimum of two scalars.


.. function:: min(x: vec[2, <class 'warp.types.float64'>], y: vec[2, <class 'warp.types.float64'>]) -> vec[2, <class 'warp.types.float64'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[3, <class 'warp.types.float64'>], y: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[4, <class 'warp.types.float64'>], y: vec[4, <class 'warp.types.float64'>]) -> vec[4, <class 'warp.types.float64'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[2, <class 'warp.types.uint8'>], y: vec[2, <class 'warp.types.uint8'>]) -> vec[2, <class 'warp.types.uint8'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[3, <class 'warp.types.uint8'>], y: vec[3, <class 'warp.types.uint8'>]) -> vec[3, <class 'warp.types.uint8'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[4, <class 'warp.types.uint8'>], y: vec[4, <class 'warp.types.uint8'>]) -> vec[4, <class 'warp.types.uint8'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[2, <class 'warp.types.float16'>], y: vec[2, <class 'warp.types.float16'>]) -> vec[2, <class 'warp.types.float16'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[3, <class 'warp.types.float16'>], y: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[4, <class 'warp.types.float16'>], y: vec[4, <class 'warp.types.float16'>]) -> vec[4, <class 'warp.types.float16'>]

   Return the element wise minimum of two vectors.


.. function:: min(x: vec[typing.Any, ~Scalar], y: vec[typing.Any, ~Scalar]) -> vec[typing.Any, ~Scalar]

   Return the element wise minimum of two vectors.


.. function:: max(x: uint32, y: uint32) -> uint32

   Return the maximum of two scalars.


.. function:: max(x: int16, y: int16) -> int16

   Return the maximum of two scalars.


.. function:: max(x: float64, y: float64) -> float64

   Return the maximum of two scalars.


.. function:: max(x: int8, y: int8) -> int8

   Return the maximum of two scalars.


.. function:: max(x: float16, y: float16) -> float16

   Return the maximum of two scalars.


.. function:: max(x: uint16, y: uint16) -> uint16

   Return the maximum of two scalars.


.. function:: max(x: int32, y: int32) -> int32

   Return the maximum of two scalars.


.. function:: max(x: uint64, y: uint64) -> uint64

   Return the maximum of two scalars.


.. function:: max(x: float32, y: float32) -> float32

   Return the maximum of two scalars.


.. function:: max(x: int64, y: int64) -> int64

   Return the maximum of two scalars.


.. function:: max(x: uint8, y: uint8) -> uint8

   Return the maximum of two scalars.


.. function:: max(x: Scalar, y: Scalar) -> Scalar

   Return the maximum of two scalars.


.. function:: max(x: vec[2, <class 'warp.types.float64'>], y: vec[2, <class 'warp.types.float64'>]) -> vec[2, <class 'warp.types.float64'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[3, <class 'warp.types.float64'>], y: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[4, <class 'warp.types.float64'>], y: vec[4, <class 'warp.types.float64'>]) -> vec[4, <class 'warp.types.float64'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[2, <class 'warp.types.uint8'>], y: vec[2, <class 'warp.types.uint8'>]) -> vec[2, <class 'warp.types.uint8'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[3, <class 'warp.types.uint8'>], y: vec[3, <class 'warp.types.uint8'>]) -> vec[3, <class 'warp.types.uint8'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[4, <class 'warp.types.uint8'>], y: vec[4, <class 'warp.types.uint8'>]) -> vec[4, <class 'warp.types.uint8'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[2, <class 'warp.types.float16'>], y: vec[2, <class 'warp.types.float16'>]) -> vec[2, <class 'warp.types.float16'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[3, <class 'warp.types.float16'>], y: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[4, <class 'warp.types.float16'>], y: vec[4, <class 'warp.types.float16'>]) -> vec[4, <class 'warp.types.float16'>]

   Return the element wise maximum of two vectors.


.. function:: max(x: vec[typing.Any, ~Scalar], y: vec[typing.Any, ~Scalar]) -> vec[typing.Any, ~Scalar]

   Return the element wise maximum of two vectors.


.. function:: clamp(x: uint32, a: uint32, b: uint32) -> uint32

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: int16, a: int16, b: int16) -> int16

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: float64, a: float64, b: float64) -> float64

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: int8, a: int8, b: int8) -> int8

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: float16, a: float16, b: float16) -> float16

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: uint16, a: uint16, b: uint16) -> uint16

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: int32, a: int32, b: int32) -> int32

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: uint64, a: uint64, b: uint64) -> uint64

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: float32, a: float32, b: float32) -> float32

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: int64, a: int64, b: int64) -> int64

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: uint8, a: uint8, b: uint8) -> uint8

   Clamp the value of x to the range [a, b].


.. function:: clamp(x: Scalar, a: Scalar, b: Scalar) -> Scalar

   Clamp the value of x to the range [a, b].


.. function:: abs(x: uint32) -> uint32

   Return the absolute value of x.


.. function:: abs(x: int16) -> int16

   Return the absolute value of x.


.. function:: abs(x: float64) -> float64

   Return the absolute value of x.


.. function:: abs(x: int8) -> int8

   Return the absolute value of x.


.. function:: abs(x: float16) -> float16

   Return the absolute value of x.


.. function:: abs(x: uint16) -> uint16

   Return the absolute value of x.


.. function:: abs(x: int32) -> int32

   Return the absolute value of x.


.. function:: abs(x: uint64) -> uint64

   Return the absolute value of x.


.. function:: abs(x: float32) -> float32

   Return the absolute value of x.


.. function:: abs(x: int64) -> int64

   Return the absolute value of x.


.. function:: abs(x: uint8) -> uint8

   Return the absolute value of x.


.. function:: abs(x: Scalar) -> Scalar

   Return the absolute value of x.


.. function:: sign(x: uint32) -> uint32

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: int16) -> int16

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: float64) -> float64

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: int8) -> int8

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: float16) -> float16

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: uint16) -> uint16

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: int32) -> int32

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: uint64) -> uint64

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: float32) -> float32

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: int64) -> int64

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: uint8) -> uint8

   Return -1 if x < 0, return 1 otherwise.


.. function:: sign(x: Scalar) -> Scalar

   Return -1 if x < 0, return 1 otherwise.


.. function:: step(x: uint32) -> uint32

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: int16) -> int16

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: float64) -> float64

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: int8) -> int8

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: float16) -> float16

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: uint16) -> uint16

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: int32) -> int32

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: uint64) -> uint64

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: float32) -> float32

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: int64) -> int64

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: uint8) -> uint8

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: step(x: Scalar) -> Scalar

   Return 1.0 if x < 0.0, return 0.0 otherwise.


.. function:: nonzero(x: uint32) -> uint32

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: int16) -> int16

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: float64) -> float64

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: int8) -> int8

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: float16) -> float16

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: uint16) -> uint16

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: int32) -> int32

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: uint64) -> uint64

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: float32) -> float32

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: int64) -> int64

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: uint8) -> uint8

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: nonzero(x: Scalar) -> Scalar

   Return 1.0 if x is not equal to zero, return 0.0 otherwise.


.. function:: sin(x: float64) -> float64

   Return the sine of x in radians.


.. function:: sin(x: float32) -> float32

   Return the sine of x in radians.


.. function:: sin(x: float16) -> float16

   Return the sine of x in radians.


.. function:: sin(x: Float) -> Float

   Return the sine of x in radians.


.. function:: cos(x: float64) -> float64

   Return the cosine of x in radians.


.. function:: cos(x: float32) -> float32

   Return the cosine of x in radians.


.. function:: cos(x: float16) -> float16

   Return the cosine of x in radians.


.. function:: cos(x: Float) -> Float

   Return the cosine of x in radians.


.. function:: acos(x: float64) -> float64

   Return arccos of x in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. function:: acos(x: float32) -> float32

   Return arccos of x in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. function:: acos(x: float16) -> float16

   Return arccos of x in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. function:: acos(x: Float) -> Float

   Return arccos of x in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. function:: asin(x: float64) -> float64

   Return arcsin of x in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. function:: asin(x: float32) -> float32

   Return arcsin of x in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. function:: asin(x: float16) -> float16

   Return arcsin of x in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. function:: asin(x: Float) -> Float

   Return arcsin of x in radians. Inputs are automatically clamped to [-1.0, 1.0].


.. function:: sqrt(x: float64) -> float64

   Return the sqrt of x, where x is positive.


.. function:: sqrt(x: float32) -> float32

   Return the sqrt of x, where x is positive.


.. function:: sqrt(x: float16) -> float16

   Return the sqrt of x, where x is positive.


.. function:: sqrt(x: Float) -> Float

   Return the sqrt of x, where x is positive.


.. function:: tan(x: float64) -> float64

   Return tangent of x in radians.


.. function:: tan(x: float32) -> float32

   Return tangent of x in radians.


.. function:: tan(x: float16) -> float16

   Return tangent of x in radians.


.. function:: tan(x: Float) -> Float

   Return tangent of x in radians.


.. function:: atan(x: float64) -> float64

   Return arctan of x.


.. function:: atan(x: float32) -> float32

   Return arctan of x.


.. function:: atan(x: float16) -> float16

   Return arctan of x.


.. function:: atan(x: Float) -> Float

   Return arctan of x.


.. function:: atan2(y: float64, x: float64) -> float64

   Return atan2 of x.


.. function:: atan2(y: float32, x: float32) -> float32

   Return atan2 of x.


.. function:: atan2(y: float16, x: float16) -> float16

   Return atan2 of x.


.. function:: atan2(y: Float, x: Float) -> Float

   Return atan2 of x.


.. function:: sinh(x: float64) -> float64

   Return the sinh of x.


.. function:: sinh(x: float32) -> float32

   Return the sinh of x.


.. function:: sinh(x: float16) -> float16

   Return the sinh of x.


.. function:: sinh(x: Float) -> Float

   Return the sinh of x.


.. function:: cosh(x: float64) -> float64

   Return the cosh of x.


.. function:: cosh(x: float32) -> float32

   Return the cosh of x.


.. function:: cosh(x: float16) -> float16

   Return the cosh of x.


.. function:: cosh(x: Float) -> Float

   Return the cosh of x.


.. function:: tanh(x: float64) -> float64

   Return the tanh of x.


.. function:: tanh(x: float32) -> float32

   Return the tanh of x.


.. function:: tanh(x: float16) -> float16

   Return the tanh of x.


.. function:: tanh(x: Float) -> Float

   Return the tanh of x.


.. function:: degrees(x: float32) -> float

   Convert radians into degrees.


.. function:: radians(x: float32) -> float

   Convert degrees into radians.


.. function:: log(x: float64) -> float64

   Return the natural log (base-e) of x, where x is positive.


.. function:: log(x: float32) -> float32

   Return the natural log (base-e) of x, where x is positive.


.. function:: log(x: float16) -> float16

   Return the natural log (base-e) of x, where x is positive.


.. function:: log(x: Float) -> Float

   Return the natural log (base-e) of x, where x is positive.


.. function:: log2(x: float64) -> float64

   Return the natural log (base-2) of x, where x is positive.


.. function:: log2(x: float32) -> float32

   Return the natural log (base-2) of x, where x is positive.


.. function:: log2(x: float16) -> float16

   Return the natural log (base-2) of x, where x is positive.


.. function:: log2(x: Float) -> Float

   Return the natural log (base-2) of x, where x is positive.


.. function:: log10(x: float64) -> float64

   Return the natural log (base-10) of x, where x is positive.


.. function:: log10(x: float32) -> float32

   Return the natural log (base-10) of x, where x is positive.


.. function:: log10(x: float16) -> float16

   Return the natural log (base-10) of x, where x is positive.


.. function:: log10(x: Float) -> Float

   Return the natural log (base-10) of x, where x is positive.


.. function:: exp(x: float64) -> float64

   Return base-e exponential, e^x.


.. function:: exp(x: float32) -> float32

   Return base-e exponential, e^x.


.. function:: exp(x: float16) -> float16

   Return base-e exponential, e^x.


.. function:: exp(x: Float) -> Float

   Return base-e exponential, e^x.


.. function:: pow(x: float64, y: float64) -> float64

   Return the result of x raised to power of y.


.. function:: pow(x: float32, y: float32) -> float32

   Return the result of x raised to power of y.


.. function:: pow(x: float16, y: float16) -> float16

   Return the result of x raised to power of y.


.. function:: pow(x: Float, y: Float) -> Float

   Return the result of x raised to power of y.


.. function:: round(x: float64) -> float64

   Calculate the nearest integer value, rounding halfway cases away from zero.
This is the most intuitive form of rounding in the colloquial sense, but can be slower than other options like ``warp.rint()``.
Differs from ``numpy.round()``, which behaves the same way as ``numpy.rint()``.


.. function:: round(x: float32) -> float32

   Calculate the nearest integer value, rounding halfway cases away from zero.
This is the most intuitive form of rounding in the colloquial sense, but can be slower than other options like ``warp.rint()``.
Differs from ``numpy.round()``, which behaves the same way as ``numpy.rint()``.


.. function:: round(x: float16) -> float16

   Calculate the nearest integer value, rounding halfway cases away from zero.
This is the most intuitive form of rounding in the colloquial sense, but can be slower than other options like ``warp.rint()``.
Differs from ``numpy.round()``, which behaves the same way as ``numpy.rint()``.


.. function:: round(x: Float) -> Float

   Calculate the nearest integer value, rounding halfway cases away from zero.
This is the most intuitive form of rounding in the colloquial sense, but can be slower than other options like ``warp.rint()``.
Differs from ``numpy.round()``, which behaves the same way as ``numpy.rint()``.


.. function:: rint(x: float64) -> float64

   Calculate the nearest integer value, rounding halfway cases to nearest even integer.
It is generally faster than ``warp.round()``.
Equivalent to ``numpy.rint()``.


.. function:: rint(x: float32) -> float32

   Calculate the nearest integer value, rounding halfway cases to nearest even integer.
It is generally faster than ``warp.round()``.
Equivalent to ``numpy.rint()``.


.. function:: rint(x: float16) -> float16

   Calculate the nearest integer value, rounding halfway cases to nearest even integer.
It is generally faster than ``warp.round()``.
Equivalent to ``numpy.rint()``.


.. function:: rint(x: Float) -> Float

   Calculate the nearest integer value, rounding halfway cases to nearest even integer.
It is generally faster than ``warp.round()``.
Equivalent to ``numpy.rint()``.


.. function:: trunc(x: float64) -> float64

   Calculate the nearest integer that is closer to zero than x.
In other words, it discards the fractional part of x.
It is similar to casting ``float(int(x))``, but preserves the negative sign when x is in the range [-0.0, -1.0).
Equivalent to ``numpy.trunc()`` and ``numpy.fix()``.


.. function:: trunc(x: float32) -> float32

   Calculate the nearest integer that is closer to zero than x.
In other words, it discards the fractional part of x.
It is similar to casting ``float(int(x))``, but preserves the negative sign when x is in the range [-0.0, -1.0).
Equivalent to ``numpy.trunc()`` and ``numpy.fix()``.


.. function:: trunc(x: float16) -> float16

   Calculate the nearest integer that is closer to zero than x.
In other words, it discards the fractional part of x.
It is similar to casting ``float(int(x))``, but preserves the negative sign when x is in the range [-0.0, -1.0).
Equivalent to ``numpy.trunc()`` and ``numpy.fix()``.


.. function:: trunc(x: Float) -> Float

   Calculate the nearest integer that is closer to zero than x.
In other words, it discards the fractional part of x.
It is similar to casting ``float(int(x))``, but preserves the negative sign when x is in the range [-0.0, -1.0).
Equivalent to ``numpy.trunc()`` and ``numpy.fix()``.


.. function:: floor(x: float64) -> float64

   Calculate the largest integer that is less than or equal to x.


.. function:: floor(x: float32) -> float32

   Calculate the largest integer that is less than or equal to x.


.. function:: floor(x: float16) -> float16

   Calculate the largest integer that is less than or equal to x.


.. function:: floor(x: Float) -> Float

   Calculate the largest integer that is less than or equal to x.


.. function:: ceil(x: float64) -> float64

   Calculate the smallest integer that is greater than or equal to x.


.. function:: ceil(x: float32) -> float32

   Calculate the smallest integer that is greater than or equal to x.


.. function:: ceil(x: float16) -> float16

   Calculate the smallest integer that is greater than or equal to x.


.. function:: ceil(x: Float) -> Float

   Calculate the smallest integer that is greater than or equal to x.




Vector Math
---------------
.. function:: dot(x: vec[2, <class 'warp.types.float64'>], y: vec[2, <class 'warp.types.float64'>]) -> float64

   Compute the dot product between two vectors.


.. function:: dot(x: vec[3, <class 'warp.types.float64'>], y: vec[3, <class 'warp.types.float64'>]) -> float64

   Compute the dot product between two vectors.


.. function:: dot(x: vec[4, <class 'warp.types.float64'>], y: vec[4, <class 'warp.types.float64'>]) -> float64

   Compute the dot product between two vectors.


.. function:: dot(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> float32

   Compute the dot product between two vectors.


.. function:: dot(x: vec[2, <class 'warp.types.uint8'>], y: vec[2, <class 'warp.types.uint8'>]) -> uint8

   Compute the dot product between two vectors.


.. function:: dot(x: vec[3, <class 'warp.types.uint8'>], y: vec[3, <class 'warp.types.uint8'>]) -> uint8

   Compute the dot product between two vectors.


.. function:: dot(x: vec[4, <class 'warp.types.uint8'>], y: vec[4, <class 'warp.types.uint8'>]) -> uint8

   Compute the dot product between two vectors.


.. function:: dot(x: vec[2, <class 'warp.types.float16'>], y: vec[2, <class 'warp.types.float16'>]) -> float16

   Compute the dot product between two vectors.


.. function:: dot(x: vec[3, <class 'warp.types.float16'>], y: vec[3, <class 'warp.types.float16'>]) -> float16

   Compute the dot product between two vectors.


.. function:: dot(x: vec[4, <class 'warp.types.float16'>], y: vec[4, <class 'warp.types.float16'>]) -> float16

   Compute the dot product between two vectors.


.. function:: dot(x: vec[typing.Any, ~Scalar], y: vec[typing.Any, ~Scalar]) -> Scalar

   Compute the dot product between two vectors.


.. function:: dot(x: quaternion[<class 'warp.types.float64'>], y: quaternion[<class 'warp.types.float64'>]) -> float64

   Compute the dot product between two quaternions.


.. function:: dot(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> float32

   Compute the dot product between two quaternions.


.. function:: dot(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> float32

   Compute the dot product between two quaternions.


.. function:: dot(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> float32

   Compute the dot product between two quaternions.


.. function:: dot(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> float32

   Compute the dot product between two quaternions.


.. function:: dot(x: quaternion[<class 'warp.types.float16'>], y: quaternion[<class 'warp.types.float16'>]) -> float16

   Compute the dot product between two quaternions.


.. function:: dot(x: quaternion[~Float], y: quaternion[~Float]) -> Scalar

   Compute the dot product between two quaternions.


.. function:: ddot(x: mat[2, 2, <class 'warp.types.float64'>], y: mat[2, 2, <class 'warp.types.float64'>]) -> float64

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[3, 3, <class 'warp.types.float64'>], y: mat[3, 3, <class 'warp.types.float64'>]) -> float64

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[4, 4, <class 'warp.types.float64'>], y: mat[4, 4, <class 'warp.types.float64'>]) -> float64

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> float32

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[2, 2, <class 'warp.types.float16'>], y: mat[2, 2, <class 'warp.types.float16'>]) -> float16

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[3, 3, <class 'warp.types.float16'>], y: mat[3, 3, <class 'warp.types.float16'>]) -> float16

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[4, 4, <class 'warp.types.float16'>], y: mat[4, 4, <class 'warp.types.float16'>]) -> float16

   Compute the double dot product between two matrices.


.. function:: ddot(x: mat[typing.Any, typing.Any, ~Scalar], y: mat[typing.Any, typing.Any, ~Scalar]) -> Scalar

   Compute the double dot product between two matrices.


.. function:: outer(x: vec[2, <class 'warp.types.float64'>], y: vec[2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[3, <class 'warp.types.float64'>], y: vec[3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[4, <class 'warp.types.float64'>], y: vec[4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[2, <class 'warp.types.float16'>], y: vec[2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[3, <class 'warp.types.float16'>], y: vec[3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[4, <class 'warp.types.float16'>], y: vec[4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: vec[typing.Any, ~Scalar], y: vec[typing.Any, ~Scalar]) -> mat[typing.Any, typing.Any, ~Scalar]

   Compute the outer product x*y^T for two vec2 objects.


.. function:: outer(x: spatial_vector_t[<class 'warp.types.float64'>], y: spatial_vector_t[<class 'warp.types.float64'>]) -> spatial_matrix_t[<class 'warp.types.float64'>]

   Compute the outer product x*y^T for two spatial_vector objects.


.. function:: outer(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]

   Compute the outer product x*y^T for two spatial_vector objects.


.. function:: outer(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]

   Compute the outer product x*y^T for two spatial_vector objects.


.. function:: outer(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]

   Compute the outer product x*y^T for two spatial_vector objects.


.. function:: outer(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]

   Compute the outer product x*y^T for two spatial_vector objects.


.. function:: outer(x: spatial_vector_t[<class 'warp.types.float16'>], y: spatial_vector_t[<class 'warp.types.float16'>]) -> spatial_matrix_t[<class 'warp.types.float16'>]

   Compute the outer product x*y^T for two spatial_vector objects.


.. function:: outer(x: spatial_vector_t[~Float], y: spatial_vector_t[~Float]) -> spatial_matrix_t[~Float]

   Compute the outer product x*y^T for two spatial_vector objects.


.. function:: cross(x: vec[3, <class 'warp.types.float64'>], y: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Compute the cross product of two 3d vectors.


.. function:: cross(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Compute the cross product of two 3d vectors.


.. function:: cross(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Compute the cross product of two 3d vectors.


.. function:: cross(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Compute the cross product of two 3d vectors.


.. function:: cross(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Compute the cross product of two 3d vectors.


.. function:: cross(x: vec[3, <class 'warp.types.uint8'>], y: vec[3, <class 'warp.types.uint8'>]) -> vec[3, <class 'warp.types.uint8'>]

   Compute the cross product of two 3d vectors.


.. function:: cross(x: vec[3, <class 'warp.types.float16'>], y: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Compute the cross product of two 3d vectors.


.. function:: cross(x: vec[3, ~Scalar], y: vec[3, ~Scalar]) -> vec[3, ~Scalar]

   Compute the cross product of two 3d vectors.


.. function:: skew(x: vec[3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]

   Compute the skew symmetric matrix for a 3d vector.


.. function:: skew(x: vec[3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Compute the skew symmetric matrix for a 3d vector.


.. function:: skew(x: vec[3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Compute the skew symmetric matrix for a 3d vector.


.. function:: skew(x: vec[3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]

   Compute the skew symmetric matrix for a 3d vector.


.. function:: skew(x: vec[3, ~Scalar])

   Compute the skew symmetric matrix for a 3d vector.


.. function:: length(x: vec[2, <class 'warp.types.float64'>]) -> float64

   Compute the length of a vector.


.. function:: length(x: vec[3, <class 'warp.types.float64'>]) -> float64

   Compute the length of a vector.


.. function:: length(x: vec[4, <class 'warp.types.float64'>]) -> float64

   Compute the length of a vector.


.. function:: length(x: vec[2, <class 'warp.types.float32'>]) -> float32

   Compute the length of a vector.


.. function:: length(x: vec[2, <class 'warp.types.float32'>]) -> float32

   Compute the length of a vector.


.. function:: length(x: vec[3, <class 'warp.types.float32'>]) -> float32

   Compute the length of a vector.


.. function:: length(x: vec[3, <class 'warp.types.float32'>]) -> float32

   Compute the length of a vector.


.. function:: length(x: vec[4, <class 'warp.types.float32'>]) -> float32

   Compute the length of a vector.


.. function:: length(x: vec[4, <class 'warp.types.float32'>]) -> float32

   Compute the length of a vector.


.. function:: length(x: vec[2, <class 'warp.types.float16'>]) -> float16

   Compute the length of a vector.


.. function:: length(x: vec[3, <class 'warp.types.float16'>]) -> float16

   Compute the length of a vector.


.. function:: length(x: vec[4, <class 'warp.types.float16'>]) -> float16

   Compute the length of a vector.


.. function:: length(x: vec[typing.Any, ~Float]) -> Scalar

   Compute the length of a vector.


.. function:: length(x: quaternion[<class 'warp.types.float64'>]) -> float64

   Compute the length of a quaternion.


.. function:: length(x: quaternion[<class 'warp.types.float32'>]) -> float32

   Compute the length of a quaternion.


.. function:: length(x: quaternion[<class 'warp.types.float32'>]) -> float32

   Compute the length of a quaternion.


.. function:: length(x: quaternion[<class 'warp.types.float16'>]) -> float16

   Compute the length of a quaternion.


.. function:: length(x: quaternion[~Float]) -> Scalar

   Compute the length of a quaternion.


.. function:: length_sq(x: vec[2, <class 'warp.types.float64'>]) -> float64

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[3, <class 'warp.types.float64'>]) -> float64

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[4, <class 'warp.types.float64'>]) -> float64

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[2, <class 'warp.types.float32'>]) -> float32

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[2, <class 'warp.types.float32'>]) -> float32

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[3, <class 'warp.types.float32'>]) -> float32

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[3, <class 'warp.types.float32'>]) -> float32

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[4, <class 'warp.types.float32'>]) -> float32

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[4, <class 'warp.types.float32'>]) -> float32

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[2, <class 'warp.types.uint8'>]) -> uint8

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[3, <class 'warp.types.uint8'>]) -> uint8

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[4, <class 'warp.types.uint8'>]) -> uint8

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[2, <class 'warp.types.float16'>]) -> float16

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[3, <class 'warp.types.float16'>]) -> float16

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[4, <class 'warp.types.float16'>]) -> float16

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: vec[typing.Any, ~Scalar]) -> Scalar

   Compute the squared length of a 2d vector.


.. function:: length_sq(x: quaternion[<class 'warp.types.float64'>]) -> float64

   Compute the squared length of a quaternion.


.. function:: length_sq(x: quaternion[<class 'warp.types.float32'>]) -> float32

   Compute the squared length of a quaternion.


.. function:: length_sq(x: quaternion[<class 'warp.types.float32'>]) -> float32

   Compute the squared length of a quaternion.


.. function:: length_sq(x: quaternion[<class 'warp.types.float16'>]) -> float16

   Compute the squared length of a quaternion.


.. function:: length_sq(x: quaternion[~Scalar]) -> Scalar

   Compute the squared length of a quaternion.


.. function:: normalize(x: vec[2, <class 'warp.types.float64'>]) -> vec[2, <class 'warp.types.float64'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[4, <class 'warp.types.float64'>]) -> vec[4, <class 'warp.types.float64'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[2, <class 'warp.types.float16'>]) -> vec[2, <class 'warp.types.float16'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[4, <class 'warp.types.float16'>]) -> vec[4, <class 'warp.types.float16'>]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: vec[typing.Any, ~Float]) -> vec[typing.Any, ~Scalar]

   Compute the normalized value of x, if length(x) is 0 then the zero vector is returned.


.. function:: normalize(x: quaternion[<class 'warp.types.float64'>]) -> quaternion[<class 'warp.types.float64'>]

   Compute the normalized value of x, if length(x) is 0 then the zero quat is returned.


.. function:: normalize(x: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]

   Compute the normalized value of x, if length(x) is 0 then the zero quat is returned.


.. function:: normalize(x: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]

   Compute the normalized value of x, if length(x) is 0 then the zero quat is returned.


.. function:: normalize(x: quaternion[<class 'warp.types.float16'>]) -> quaternion[<class 'warp.types.float16'>]

   Compute the normalized value of x, if length(x) is 0 then the zero quat is returned.


.. function:: normalize(x: quaternion[~Float]) -> quaternion[~Scalar]

   Compute the normalized value of x, if length(x) is 0 then the zero quat is returned.


.. function:: transpose(m: mat[2, 2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[3, 3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[4, 4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[2, 2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[3, 3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[4, 4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]

   Return the transpose of the matrix m


.. function:: transpose(m: mat[typing.Any, typing.Any, ~Scalar])

   Return the transpose of the matrix m


.. function:: transpose(m: spatial_matrix_t[<class 'warp.types.float64'>]) -> spatial_matrix_t[<class 'warp.types.float64'>]

   Return the transpose of the matrix m


.. function:: transpose(m: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]

   Return the transpose of the matrix m


.. function:: transpose(m: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]

   Return the transpose of the matrix m


.. function:: transpose(m: spatial_matrix_t[<class 'warp.types.float16'>]) -> spatial_matrix_t[<class 'warp.types.float16'>]

   Return the transpose of the matrix m


.. function:: transpose(m: spatial_matrix_t[~Scalar]) -> spatial_matrix_t[~Scalar]

   Return the transpose of the matrix m


.. function:: inverse(m: mat[2, 2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[3, 3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[4, 4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[2, 2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[3, 3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[4, 4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]

   Return the inverse of the matrix m


.. function:: inverse(m: mat[typing.Any, typing.Any, ~Float]) -> mat[typing.Any, typing.Any, ~Float]

   Return the inverse of the matrix m


.. function:: determinant(m: mat[2, 2, <class 'warp.types.float64'>]) -> float64

   Return the determinant of the matrix m


.. function:: determinant(m: mat[3, 3, <class 'warp.types.float64'>]) -> float64

   Return the determinant of the matrix m


.. function:: determinant(m: mat[4, 4, <class 'warp.types.float64'>]) -> float64

   Return the determinant of the matrix m


.. function:: determinant(m: mat[2, 2, <class 'warp.types.float32'>]) -> float32

   Return the determinant of the matrix m


.. function:: determinant(m: mat[2, 2, <class 'warp.types.float32'>]) -> float32

   Return the determinant of the matrix m


.. function:: determinant(m: mat[3, 3, <class 'warp.types.float32'>]) -> float32

   Return the determinant of the matrix m


.. function:: determinant(m: mat[3, 3, <class 'warp.types.float32'>]) -> float32

   Return the determinant of the matrix m


.. function:: determinant(m: mat[4, 4, <class 'warp.types.float32'>]) -> float32

   Return the determinant of the matrix m


.. function:: determinant(m: mat[4, 4, <class 'warp.types.float32'>]) -> float32

   Return the determinant of the matrix m


.. function:: determinant(m: mat[2, 2, <class 'warp.types.float16'>]) -> float16

   Return the determinant of the matrix m


.. function:: determinant(m: mat[3, 3, <class 'warp.types.float16'>]) -> float16

   Return the determinant of the matrix m


.. function:: determinant(m: mat[4, 4, <class 'warp.types.float16'>]) -> float16

   Return the determinant of the matrix m


.. function:: determinant(m: mat[typing.Any, typing.Any, ~Scalar]) -> Scalar

   Return the determinant of the matrix m


.. function:: trace(m: mat[2, 2, <class 'warp.types.float64'>]) -> float64

   Return the trace of the matrix m


.. function:: trace(m: mat[3, 3, <class 'warp.types.float64'>]) -> float64

   Return the trace of the matrix m


.. function:: trace(m: mat[4, 4, <class 'warp.types.float64'>]) -> float64

   Return the trace of the matrix m


.. function:: trace(m: mat[2, 2, <class 'warp.types.float32'>]) -> float32

   Return the trace of the matrix m


.. function:: trace(m: mat[2, 2, <class 'warp.types.float32'>]) -> float32

   Return the trace of the matrix m


.. function:: trace(m: mat[3, 3, <class 'warp.types.float32'>]) -> float32

   Return the trace of the matrix m


.. function:: trace(m: mat[3, 3, <class 'warp.types.float32'>]) -> float32

   Return the trace of the matrix m


.. function:: trace(m: mat[4, 4, <class 'warp.types.float32'>]) -> float32

   Return the trace of the matrix m


.. function:: trace(m: mat[4, 4, <class 'warp.types.float32'>]) -> float32

   Return the trace of the matrix m


.. function:: trace(m: mat[2, 2, <class 'warp.types.float16'>]) -> float16

   Return the trace of the matrix m


.. function:: trace(m: mat[3, 3, <class 'warp.types.float16'>]) -> float16

   Return the trace of the matrix m


.. function:: trace(m: mat[4, 4, <class 'warp.types.float16'>]) -> float16

   Return the trace of the matrix m


.. function:: trace(m: mat[typing.Any, typing.Any, ~Scalar]) -> Scalar

   Return the trace of the matrix m


.. function:: diag(d: vec[2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]

   Returns a matrix with the components of the vector d on the diagonal


.. function:: diag(d: vec[typing.Any, ~Scalar])

   Returns a matrix with the components of the vector d on the diagonal


.. function:: cw_mul(x: vec[2, <class 'warp.types.float64'>], y: vec[2, <class 'warp.types.float64'>]) -> vec[2, <class 'warp.types.float64'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[3, <class 'warp.types.float64'>], y: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[4, <class 'warp.types.float64'>], y: vec[4, <class 'warp.types.float64'>]) -> vec[4, <class 'warp.types.float64'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[2, <class 'warp.types.uint8'>], y: vec[2, <class 'warp.types.uint8'>]) -> vec[2, <class 'warp.types.uint8'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[3, <class 'warp.types.uint8'>], y: vec[3, <class 'warp.types.uint8'>]) -> vec[3, <class 'warp.types.uint8'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[4, <class 'warp.types.uint8'>], y: vec[4, <class 'warp.types.uint8'>]) -> vec[4, <class 'warp.types.uint8'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[2, <class 'warp.types.float16'>], y: vec[2, <class 'warp.types.float16'>]) -> vec[2, <class 'warp.types.float16'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[3, <class 'warp.types.float16'>], y: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[4, <class 'warp.types.float16'>], y: vec[4, <class 'warp.types.float16'>]) -> vec[4, <class 'warp.types.float16'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: vec[typing.Any, ~Scalar], y: vec[typing.Any, ~Scalar]) -> vec[typing.Any, ~Scalar]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[2, 2, <class 'warp.types.float64'>], y: mat[2, 2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[3, 3, <class 'warp.types.float64'>], y: mat[3, 3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[4, 4, <class 'warp.types.float64'>], y: mat[4, 4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[2, 2, <class 'warp.types.float16'>], y: mat[2, 2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[3, 3, <class 'warp.types.float16'>], y: mat[3, 3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[4, 4, <class 'warp.types.float16'>], y: mat[4, 4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]

   Component wise multiply of two 2d vectors.


.. function:: cw_mul(x: mat[typing.Any, typing.Any, ~Scalar], y: mat[typing.Any, typing.Any, ~Scalar]) -> mat[typing.Any, typing.Any, ~Scalar]

   Component wise multiply of two 2d vectors.


.. function:: cw_div(x: vec[2, <class 'warp.types.float64'>], y: vec[2, <class 'warp.types.float64'>]) -> vec[2, <class 'warp.types.float64'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[3, <class 'warp.types.float64'>], y: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[4, <class 'warp.types.float64'>], y: vec[4, <class 'warp.types.float64'>]) -> vec[4, <class 'warp.types.float64'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[2, <class 'warp.types.uint8'>], y: vec[2, <class 'warp.types.uint8'>]) -> vec[2, <class 'warp.types.uint8'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[3, <class 'warp.types.uint8'>], y: vec[3, <class 'warp.types.uint8'>]) -> vec[3, <class 'warp.types.uint8'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[4, <class 'warp.types.uint8'>], y: vec[4, <class 'warp.types.uint8'>]) -> vec[4, <class 'warp.types.uint8'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[2, <class 'warp.types.float16'>], y: vec[2, <class 'warp.types.float16'>]) -> vec[2, <class 'warp.types.float16'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[3, <class 'warp.types.float16'>], y: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[4, <class 'warp.types.float16'>], y: vec[4, <class 'warp.types.float16'>]) -> vec[4, <class 'warp.types.float16'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: vec[typing.Any, ~Scalar], y: vec[typing.Any, ~Scalar]) -> vec[typing.Any, ~Scalar]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[2, 2, <class 'warp.types.float64'>], y: mat[2, 2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[3, 3, <class 'warp.types.float64'>], y: mat[3, 3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[4, 4, <class 'warp.types.float64'>], y: mat[4, 4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[2, 2, <class 'warp.types.float16'>], y: mat[2, 2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[3, 3, <class 'warp.types.float16'>], y: mat[3, 3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[4, 4, <class 'warp.types.float16'>], y: mat[4, 4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]

   Component wise division of two 2d vectors.


.. function:: cw_div(x: mat[typing.Any, typing.Any, ~Scalar], y: mat[typing.Any, typing.Any, ~Scalar]) -> mat[typing.Any, typing.Any, ~Scalar]

   Component wise division of two 2d vectors.


.. function:: vec() -> vec[typing.Any, ~Scalar]

   Construct a zero-initialized vector.


.. function:: vec(s: Scalar) -> vec[typing.Any, ~Scalar]

   Construct a vector with all components set to s.


.. function:: vec() -> vec[typing.Any, ~Scalar]

   Construct a vector from scalar compontents.


.. function:: mat() -> mat[typing.Any, typing.Any, ~Scalar]

   Construct a zero matrix


.. function:: mat(s: Scalar) -> mat[typing.Any, typing.Any, ~Scalar]

   Construct a matrix with all components set to s


.. function:: mat(pos: vec[3, ~Float], rot: quaternion[~Float], scale: vec[3, ~Float]) -> mat[typing.Any, typing.Any, ~Float]

   Construct a 4x4 transformation matrix that applies the transformations as Translation(pos)*Rotation(rot)*Scale(scale) when applied to column vectors, i.e.: y = (TRS)*x


.. function:: mat() -> mat[typing.Any, typing.Any, ~Scalar]

   Construct a matrix from components or column vectors.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float64'>], U: mat[3, 3, <class 'warp.types.float64'>], sigma: vec[3, <class 'warp.types.float64'>], V: mat[3, 3, <class 'warp.types.float64'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float16'>], U: mat[3, 3, <class 'warp.types.float16'>], sigma: vec[3, <class 'warp.types.float16'>], V: mat[3, 3, <class 'warp.types.float16'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, <class 'warp.types.float32'>], U: mat[3, 3, <class 'warp.types.float32'>], sigma: vec[3, <class 'warp.types.float32'>], V: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: svd3(A: mat[3, 3, ~Float], U: mat[3, 3, ~Float], sigma: vec[3, ~Float], V: mat[3, 3, ~Scalar]) -> None

   Compute the SVD of a 3x3 matrix. The singular values are returned in sigma, 
   while the left and right basis vectors are returned in U and V.


.. function:: qr3(A: mat[3, 3, <class 'warp.types.float64'>], Q: mat[3, 3, <class 'warp.types.float64'>], R: mat[3, 3, <class 'warp.types.float64'>]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: qr3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], R: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: qr3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], R: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: qr3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], R: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: qr3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], R: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: qr3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], R: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: qr3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], R: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: qr3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], R: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: qr3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], R: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: qr3(A: mat[3, 3, <class 'warp.types.float16'>], Q: mat[3, 3, <class 'warp.types.float16'>], R: mat[3, 3, <class 'warp.types.float16'>]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: qr3(A: mat[3, 3, ~Float], Q: mat[3, 3, ~Float], R: mat[3, 3, ~Float]) -> None

   Compute the QR decomposition of a 3x3 matrix. The orthogonal matrix is returned in Q, while the upper triangular matrix is returend in R.


.. function:: eig3(A: mat[3, 3, <class 'warp.types.float64'>], Q: mat[3, 3, <class 'warp.types.float64'>], d: vec[3, <class 'warp.types.float64'>]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.


.. function:: eig3(A: mat[3, 3, <class 'warp.types.float16'>], Q: mat[3, 3, <class 'warp.types.float16'>], d: vec[3, <class 'warp.types.float16'>]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.


.. function:: eig3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], d: vec[3, <class 'warp.types.float32'>]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.


.. function:: eig3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], d: vec[3, <class 'warp.types.float32'>]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.


.. function:: eig3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], d: vec[3, <class 'warp.types.float32'>]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.


.. function:: eig3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], d: vec[3, <class 'warp.types.float32'>]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.


.. function:: eig3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], d: vec[3, <class 'warp.types.float32'>]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.


.. function:: eig3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], d: vec[3, <class 'warp.types.float32'>]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.


.. function:: eig3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], d: vec[3, <class 'warp.types.float32'>]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.


.. function:: eig3(A: mat[3, 3, <class 'warp.types.float32'>], Q: mat[3, 3, <class 'warp.types.float32'>], d: vec[3, <class 'warp.types.float32'>]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.


.. function:: eig3(A: mat[3, 3, ~Float], Q: mat[3, 3, ~Float], d: vec[3, ~Float]) -> None

   Compute the eigen decomposition of a 3x3 marix. The eigen vectors are returned as the columns of Q, while the corresponding eigen values are returned in d.




Quaternion Math
---------------
.. function:: quaternion() -> quaternion[~Float]

   Construct a zero-initialized quaternion, quaternions are laid out as
   [ix, iy, iz, r], where ix, iy, iz are the imaginary part, and r the real part.


.. function:: quaternion(x: Float, y: Float, z: Float, w: Float) -> quaternion[~Float]

   Construct a quarternion from its components x, y, z are the imaginary parts, w is the real part.


.. function:: quaternion(i: vec[3, ~Float], r: Float) -> quaternion[~Float]

   Construct a quaternion from it's imaginary components i, and real part r


.. function:: quat_identity() -> quaternion[<class 'warp.types.float32'>]

   Construct a float32 identity quaternion with zero imaginary part and real part of 1.0


.. function:: quat_from_axis_angle(axis: vec[3, <class 'warp.types.float64'>], angle: float64) -> quaternion[<class 'warp.types.float64'>]

   Construct a quaternion representing a rotation of angle radians around the given axis.


.. function:: quat_from_axis_angle(axis: vec[3, <class 'warp.types.float16'>], angle: float16) -> quaternion[<class 'warp.types.float16'>]

   Construct a quaternion representing a rotation of angle radians around the given axis.


.. function:: quat_from_axis_angle(axis: vec[3, <class 'warp.types.float32'>], angle: float32) -> quaternion[<class 'warp.types.float32'>]

   Construct a quaternion representing a rotation of angle radians around the given axis.


.. function:: quat_from_axis_angle(axis: vec[3, <class 'warp.types.float32'>], angle: float32) -> quaternion[<class 'warp.types.float32'>]

   Construct a quaternion representing a rotation of angle radians around the given axis.


.. function:: quat_from_axis_angle(axis: vec[3, ~Float], angle: Float) -> quaternion[~Scalar]

   Construct a quaternion representing a rotation of angle radians around the given axis.


.. function:: quat_to_axis_angle(q: quaternion[<class 'warp.types.float64'>], axis: vec[3, <class 'warp.types.float64'>], angle: float64) -> None

   Extract the rotation axis and angle radians a quaternion represents.


.. function:: quat_to_axis_angle(q: quaternion[<class 'warp.types.float32'>], axis: vec[3, <class 'warp.types.float32'>], angle: float32) -> None

   Extract the rotation axis and angle radians a quaternion represents.


.. function:: quat_to_axis_angle(q: quaternion[<class 'warp.types.float32'>], axis: vec[3, <class 'warp.types.float32'>], angle: float32) -> None

   Extract the rotation axis and angle radians a quaternion represents.


.. function:: quat_to_axis_angle(q: quaternion[<class 'warp.types.float32'>], axis: vec[3, <class 'warp.types.float32'>], angle: float32) -> None

   Extract the rotation axis and angle radians a quaternion represents.


.. function:: quat_to_axis_angle(q: quaternion[<class 'warp.types.float32'>], axis: vec[3, <class 'warp.types.float32'>], angle: float32) -> None

   Extract the rotation axis and angle radians a quaternion represents.


.. function:: quat_to_axis_angle(q: quaternion[<class 'warp.types.float16'>], axis: vec[3, <class 'warp.types.float16'>], angle: float16) -> None

   Extract the rotation axis and angle radians a quaternion represents.


.. function:: quat_to_axis_angle(q: quaternion[~Float], axis: vec[3, ~Float], angle: Float) -> None

   Extract the rotation axis and angle radians a quaternion represents.


.. function:: quat_from_matrix(m: mat[3, 3, <class 'warp.types.float64'>]) -> quaternion[<class 'warp.types.float64'>]

   Construct a quaternion from a 3x3 matrix.


.. function:: quat_from_matrix(m: mat[3, 3, <class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]

   Construct a quaternion from a 3x3 matrix.


.. function:: quat_from_matrix(m: mat[3, 3, <class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]

   Construct a quaternion from a 3x3 matrix.


.. function:: quat_from_matrix(m: mat[3, 3, <class 'warp.types.float16'>]) -> quaternion[<class 'warp.types.float16'>]

   Construct a quaternion from a 3x3 matrix.


.. function:: quat_from_matrix(m: mat[3, 3, ~Float]) -> quaternion[~Scalar]

   Construct a quaternion from a 3x3 matrix.


.. function:: quat_rpy(roll: float64, pitch: float64, yaw: float64) -> quaternion[<class 'warp.types.float64'>]

   Construct a quaternion representing a combined roll (z), pitch (x), yaw rotations (y) in radians.


.. function:: quat_rpy(roll: float32, pitch: float32, yaw: float32) -> quaternion[<class 'warp.types.float32'>]

   Construct a quaternion representing a combined roll (z), pitch (x), yaw rotations (y) in radians.


.. function:: quat_rpy(roll: float16, pitch: float16, yaw: float16) -> quaternion[<class 'warp.types.float16'>]

   Construct a quaternion representing a combined roll (z), pitch (x), yaw rotations (y) in radians.


.. function:: quat_rpy(roll: Float, pitch: Float, yaw: Float) -> quaternion[~Scalar]

   Construct a quaternion representing a combined roll (z), pitch (x), yaw rotations (y) in radians.


.. function:: quat_inverse(q: quaternion[<class 'warp.types.float64'>]) -> quaternion[<class 'warp.types.float64'>]

   Compute quaternion conjugate.


.. function:: quat_inverse(q: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]

   Compute quaternion conjugate.


.. function:: quat_inverse(q: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]

   Compute quaternion conjugate.


.. function:: quat_inverse(q: quaternion[<class 'warp.types.float16'>]) -> quaternion[<class 'warp.types.float16'>]

   Compute quaternion conjugate.


.. function:: quat_inverse(q: quaternion[~Float]) -> quaternion[~Scalar]

   Compute quaternion conjugate.


.. function:: quat_rotate(q: quaternion[<class 'warp.types.float64'>], p: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Rotate a vector by a quaternion.


.. function:: quat_rotate(q: quaternion[<class 'warp.types.float16'>], p: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Rotate a vector by a quaternion.


.. function:: quat_rotate(q: quaternion[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Rotate a vector by a quaternion.


.. function:: quat_rotate(q: quaternion[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Rotate a vector by a quaternion.


.. function:: quat_rotate(q: quaternion[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Rotate a vector by a quaternion.


.. function:: quat_rotate(q: quaternion[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Rotate a vector by a quaternion.


.. function:: quat_rotate(q: quaternion[~Float], p: vec[3, ~Float]) -> vec[3, ~Scalar]

   Rotate a vector by a quaternion.


.. function:: quat_rotate_inv(q: quaternion[<class 'warp.types.float64'>], p: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Rotate a vector the inverse of a quaternion.


.. function:: quat_rotate_inv(q: quaternion[<class 'warp.types.float16'>], p: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Rotate a vector the inverse of a quaternion.


.. function:: quat_rotate_inv(q: quaternion[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Rotate a vector the inverse of a quaternion.


.. function:: quat_rotate_inv(q: quaternion[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Rotate a vector the inverse of a quaternion.


.. function:: quat_rotate_inv(q: quaternion[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Rotate a vector the inverse of a quaternion.


.. function:: quat_rotate_inv(q: quaternion[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Rotate a vector the inverse of a quaternion.


.. function:: quat_rotate_inv(q: quaternion[~Float], p: vec[3, ~Float]) -> vec[3, ~Scalar]

   Rotate a vector the inverse of a quaternion.


.. function:: quat_slerp(q0: quaternion[<class 'warp.types.float64'>], q1: quaternion[<class 'warp.types.float64'>], t: float64) -> quaternion[<class 'warp.types.float64'>]

   Linearly interpolate between two quaternions.


.. function:: quat_slerp(q0: quaternion[<class 'warp.types.float16'>], q1: quaternion[<class 'warp.types.float16'>], t: float16) -> quaternion[<class 'warp.types.float16'>]

   Linearly interpolate between two quaternions.


.. function:: quat_slerp(q0: quaternion[<class 'warp.types.float32'>], q1: quaternion[<class 'warp.types.float32'>], t: float32) -> quaternion[<class 'warp.types.float32'>]

   Linearly interpolate between two quaternions.


.. function:: quat_slerp(q0: quaternion[<class 'warp.types.float32'>], q1: quaternion[<class 'warp.types.float32'>], t: float32) -> quaternion[<class 'warp.types.float32'>]

   Linearly interpolate between two quaternions.


.. function:: quat_slerp(q0: quaternion[<class 'warp.types.float32'>], q1: quaternion[<class 'warp.types.float32'>], t: float32) -> quaternion[<class 'warp.types.float32'>]

   Linearly interpolate between two quaternions.


.. function:: quat_slerp(q0: quaternion[<class 'warp.types.float32'>], q1: quaternion[<class 'warp.types.float32'>], t: float32) -> quaternion[<class 'warp.types.float32'>]

   Linearly interpolate between two quaternions.


.. function:: quat_slerp(q0: quaternion[~Float], q1: quaternion[~Float], t: Float) -> quaternion[~Scalar]

   Linearly interpolate between two quaternions.


.. function:: quat_to_matrix(q: quaternion[<class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]

   Convert a quaternion to a 3x3 rotation matrix.


.. function:: quat_to_matrix(q: quaternion[<class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Convert a quaternion to a 3x3 rotation matrix.


.. function:: quat_to_matrix(q: quaternion[<class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]

   Convert a quaternion to a 3x3 rotation matrix.


.. function:: quat_to_matrix(q: quaternion[<class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]

   Convert a quaternion to a 3x3 rotation matrix.


.. function:: quat_to_matrix(q: quaternion[~Float]) -> mat[3, 3, ~Scalar]

   Convert a quaternion to a 3x3 rotation matrix.




Transformations
---------------
.. function:: transform_t(p: vec[3, ~Float], q: quaternion[~Float]) -> transform_t[~Scalar]

   Construct a rigid body transformation with translation part p and rotation q.


.. function:: transform_identity() -> transform_t[<class 'warp.types.float32'>]

   Construct a float32 identity transform with zero translation and identity rotation.


.. function:: transform_get_translation(t: transform_t[<class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Return the translational part of a transform.


.. function:: transform_get_translation(t: transform_t[<class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the translational part of a transform.


.. function:: transform_get_translation(t: transform_t[<class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the translational part of a transform.


.. function:: transform_get_translation(t: transform_t[<class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Return the translational part of a transform.


.. function:: transform_get_translation(t: transform_t[~Float]) -> vec[3, ~Scalar]

   Return the translational part of a transform.


.. function:: transform_get_rotation(t: transform_t[<class 'warp.types.float64'>]) -> quaternion[<class 'warp.types.float64'>]

   Return the rotational part of a transform.


.. function:: transform_get_rotation(t: transform_t[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]

   Return the rotational part of a transform.


.. function:: transform_get_rotation(t: transform_t[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]

   Return the rotational part of a transform.


.. function:: transform_get_rotation(t: transform_t[<class 'warp.types.float16'>]) -> quaternion[<class 'warp.types.float16'>]

   Return the rotational part of a transform.


.. function:: transform_get_rotation(t: transform_t[~Float]) -> quaternion[~Scalar]

   Return the rotational part of a transform.


.. function:: transform_multiply(a: transform_t[<class 'warp.types.float64'>], b: transform_t[<class 'warp.types.float64'>]) -> transform_t[<class 'warp.types.float64'>]

   Multiply two rigid body transformations together.


.. function:: transform_multiply(a: transform_t[<class 'warp.types.float32'>], b: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]

   Multiply two rigid body transformations together.


.. function:: transform_multiply(a: transform_t[<class 'warp.types.float32'>], b: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]

   Multiply two rigid body transformations together.


.. function:: transform_multiply(a: transform_t[<class 'warp.types.float32'>], b: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]

   Multiply two rigid body transformations together.


.. function:: transform_multiply(a: transform_t[<class 'warp.types.float32'>], b: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]

   Multiply two rigid body transformations together.


.. function:: transform_multiply(a: transform_t[<class 'warp.types.float16'>], b: transform_t[<class 'warp.types.float16'>]) -> transform_t[<class 'warp.types.float16'>]

   Multiply two rigid body transformations together.


.. function:: transform_multiply(a: transform_t[~Float], b: transform_t[~Float]) -> transform_t[~Scalar]

   Multiply two rigid body transformations together.


.. function:: transform_point(t: transform_t[<class 'warp.types.float64'>], p: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Apply the transform to a point p treating the homogenous coordinate as w=1 (translation and rotation).


.. function:: transform_point(t: transform_t[<class 'warp.types.float16'>], p: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Apply the transform to a point p treating the homogenous coordinate as w=1 (translation and rotation).


.. function:: transform_point(t: transform_t[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a point p treating the homogenous coordinate as w=1 (translation and rotation).


.. function:: transform_point(t: transform_t[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a point p treating the homogenous coordinate as w=1 (translation and rotation).


.. function:: transform_point(t: transform_t[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a point p treating the homogenous coordinate as w=1 (translation and rotation).


.. function:: transform_point(t: transform_t[<class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a point p treating the homogenous coordinate as w=1 (translation and rotation).


.. function:: transform_point(t: transform_t[~Scalar], p: vec[3, ~Scalar]) -> vec[3, ~Scalar]

   Apply the transform to a point p treating the homogenous coordinate as w=1 (translation and rotation).


.. function:: transform_point(m: mat[4, 4, <class 'warp.types.float64'>], p: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Apply the transform to a point ``p`` treating the homogenous coordinate as w=1. The transformation is applied treating ``p`` as a column vector, e.g.: ``y = M*p``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = p^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_point(m: mat[4, 4, <class 'warp.types.float16'>], p: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Apply the transform to a point ``p`` treating the homogenous coordinate as w=1. The transformation is applied treating ``p`` as a column vector, e.g.: ``y = M*p``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = p^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_point(m: mat[4, 4, <class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a point ``p`` treating the homogenous coordinate as w=1. The transformation is applied treating ``p`` as a column vector, e.g.: ``y = M*p``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = p^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_point(m: mat[4, 4, <class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a point ``p`` treating the homogenous coordinate as w=1. The transformation is applied treating ``p`` as a column vector, e.g.: ``y = M*p``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = p^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_point(m: mat[4, 4, <class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a point ``p`` treating the homogenous coordinate as w=1. The transformation is applied treating ``p`` as a column vector, e.g.: ``y = M*p``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = p^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_point(m: mat[4, 4, <class 'warp.types.float32'>], p: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a point ``p`` treating the homogenous coordinate as w=1. The transformation is applied treating ``p`` as a column vector, e.g.: ``y = M*p``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = p^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_point(m: mat[4, 4, ~Scalar], p: vec[3, ~Scalar]) -> vec[3, ~Scalar]

   Apply the transform to a point ``p`` treating the homogenous coordinate as w=1. The transformation is applied treating ``p`` as a column vector, e.g.: ``y = M*p``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = p^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_vector(t: transform_t[<class 'warp.types.float64'>], v: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Apply the transform to a vector v treating the homogenous coordinate as w=0 (rotation only).


.. function:: transform_vector(t: transform_t[<class 'warp.types.float16'>], v: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Apply the transform to a vector v treating the homogenous coordinate as w=0 (rotation only).


.. function:: transform_vector(t: transform_t[<class 'warp.types.float32'>], v: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a vector v treating the homogenous coordinate as w=0 (rotation only).


.. function:: transform_vector(t: transform_t[<class 'warp.types.float32'>], v: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a vector v treating the homogenous coordinate as w=0 (rotation only).


.. function:: transform_vector(t: transform_t[<class 'warp.types.float32'>], v: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a vector v treating the homogenous coordinate as w=0 (rotation only).


.. function:: transform_vector(t: transform_t[<class 'warp.types.float32'>], v: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a vector v treating the homogenous coordinate as w=0 (rotation only).


.. function:: transform_vector(t: transform_t[~Scalar], v: vec[3, ~Scalar]) -> vec[3, ~Scalar]

   Apply the transform to a vector v treating the homogenous coordinate as w=0 (rotation only).


.. function:: transform_vector(m: mat[4, 4, <class 'warp.types.float64'>], v: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Apply the transform to a vector ``v`` treating the homogenous coordinate as w=0. The transformation is applied treating ``v`` as a column vector, e.g.: ``y = M*v``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = v^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_vector(m: mat[4, 4, <class 'warp.types.float16'>], v: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Apply the transform to a vector ``v`` treating the homogenous coordinate as w=0. The transformation is applied treating ``v`` as a column vector, e.g.: ``y = M*v``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = v^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_vector(m: mat[4, 4, <class 'warp.types.float32'>], v: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a vector ``v`` treating the homogenous coordinate as w=0. The transformation is applied treating ``v`` as a column vector, e.g.: ``y = M*v``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = v^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_vector(m: mat[4, 4, <class 'warp.types.float32'>], v: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a vector ``v`` treating the homogenous coordinate as w=0. The transformation is applied treating ``v`` as a column vector, e.g.: ``y = M*v``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = v^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_vector(m: mat[4, 4, <class 'warp.types.float32'>], v: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a vector ``v`` treating the homogenous coordinate as w=0. The transformation is applied treating ``v`` as a column vector, e.g.: ``y = M*v``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = v^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_vector(m: mat[4, 4, <class 'warp.types.float32'>], v: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Apply the transform to a vector ``v`` treating the homogenous coordinate as w=0. The transformation is applied treating ``v`` as a column vector, e.g.: ``y = M*v``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = v^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_vector(m: mat[4, 4, ~Scalar], v: vec[3, ~Scalar]) -> vec[3, ~Scalar]

   Apply the transform to a vector ``v`` treating the homogenous coordinate as w=0. The transformation is applied treating ``v`` as a column vector, e.g.: ``y = M*v``
   note this is in contrast to some libraries, notably USD, which applies transforms to row vectors, ``y^T = v^T*M^T``. If the transform is coming from a library that uses row-vectors
   then users should transpose the tranformation matrix before calling this method.


.. function:: transform_inverse(t: transform_t[<class 'warp.types.float64'>]) -> transform_t[<class 'warp.types.float64'>]

   Compute the inverse of the transform.


.. function:: transform_inverse(t: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]

   Compute the inverse of the transform.


.. function:: transform_inverse(t: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]

   Compute the inverse of the transform.


.. function:: transform_inverse(t: transform_t[<class 'warp.types.float16'>]) -> transform_t[<class 'warp.types.float16'>]

   Compute the inverse of the transform.


.. function:: transform_inverse(t: transform_t[~Float]) -> transform_t[~Float]

   Compute the inverse of the transform.




Spatial Math
---------------
.. function:: spatial_vector_t() -> spatial_vector_t[~Float]

   Construct a zero-initialized 6d screw vector. Screw vectors may be used to represent rigid body wrenches and twists (velocites).


.. function:: spatial_vector_t(a: Float, b: Float, c: Float, d: Float, e: Float, f: Float) -> spatial_vector_t[~Float]

   Construct a 6d screw vector from it's components.


.. function:: spatial_vector_t(w: vec[3, ~Float], v: vec[3, ~Float]) -> spatial_vector_t[~Float]

   Construct a 6d screw vector from two 3d vectors.


.. function:: spatial_vector_t(s: Float) -> spatial_vector_t[~Float]

   Construct a 6d screw vector with all components set to s


.. function:: spatial_matrix_t() -> spatial_matrix_t[~Float]

   Construct a 6x6 zero-initialized spatial inertia matrix


.. function:: spatial_matrix_t(s0: Scalar, s1: Scalar, s2: Scalar, s3: Scalar, s4: Scalar, s5: Scalar, s6: Scalar, s7: Scalar, s8: Scalar, s9: Scalar, s10: Scalar, s11: Scalar, s12: Scalar, s13: Scalar, s14: Scalar, s15: Scalar, s16: Scalar, s17: Scalar, s18: Scalar, s19: Scalar, s20: Scalar, s21: Scalar, s22: Scalar, s23: Scalar, s24: Scalar, s25: Scalar, s26: Scalar, s27: Scalar, s28: Scalar, s29: Scalar, s30: Scalar, s31: Scalar, s32: Scalar, s33: Scalar, s34: Scalar, s35: Scalar) -> spatial_matrix_t[~Float]

   Construct a 6x6 spatial inertia matrix from components


.. function:: spatial_adjoint(r: mat[3, 3, ~Float], s: mat[3, 3, ~Float]) -> spatial_matrix_t[~Scalar]

   Construct a 6x6 spatial inertial matrix from two 3x3 diagonal blocks.


.. function:: spatial_dot(a: spatial_vector_t[<class 'warp.types.float64'>], b: spatial_vector_t[<class 'warp.types.float64'>]) -> float64

   Compute the dot product of two 6d screw vectors.


.. function:: spatial_dot(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> float32

   Compute the dot product of two 6d screw vectors.


.. function:: spatial_dot(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> float32

   Compute the dot product of two 6d screw vectors.


.. function:: spatial_dot(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> float32

   Compute the dot product of two 6d screw vectors.


.. function:: spatial_dot(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> float32

   Compute the dot product of two 6d screw vectors.


.. function:: spatial_dot(a: spatial_vector_t[<class 'warp.types.float16'>], b: spatial_vector_t[<class 'warp.types.float16'>]) -> float16

   Compute the dot product of two 6d screw vectors.


.. function:: spatial_dot(a: spatial_vector_t[~Float], b: spatial_vector_t[~Float]) -> Scalar

   Compute the dot product of two 6d screw vectors.


.. function:: spatial_cross(a: spatial_vector_t[<class 'warp.types.float64'>], b: spatial_vector_t[<class 'warp.types.float64'>]) -> spatial_vector_t[<class 'warp.types.float64'>]

   Compute the cross-product of two 6d screw vectors.


.. function:: spatial_cross(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]

   Compute the cross-product of two 6d screw vectors.


.. function:: spatial_cross(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]

   Compute the cross-product of two 6d screw vectors.


.. function:: spatial_cross(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]

   Compute the cross-product of two 6d screw vectors.


.. function:: spatial_cross(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]

   Compute the cross-product of two 6d screw vectors.


.. function:: spatial_cross(a: spatial_vector_t[<class 'warp.types.float16'>], b: spatial_vector_t[<class 'warp.types.float16'>]) -> spatial_vector_t[<class 'warp.types.float16'>]

   Compute the cross-product of two 6d screw vectors.


.. function:: spatial_cross(a: spatial_vector_t[~Float], b: spatial_vector_t[~Float]) -> spatial_vector_t[~Float]

   Compute the cross-product of two 6d screw vectors.


.. function:: spatial_cross_dual(a: spatial_vector_t[<class 'warp.types.float64'>], b: spatial_vector_t[<class 'warp.types.float64'>]) -> spatial_vector_t[<class 'warp.types.float64'>]

   Compute the dual cross-product of two 6d screw vectors.


.. function:: spatial_cross_dual(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]

   Compute the dual cross-product of two 6d screw vectors.


.. function:: spatial_cross_dual(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]

   Compute the dual cross-product of two 6d screw vectors.


.. function:: spatial_cross_dual(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]

   Compute the dual cross-product of two 6d screw vectors.


.. function:: spatial_cross_dual(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]

   Compute the dual cross-product of two 6d screw vectors.


.. function:: spatial_cross_dual(a: spatial_vector_t[<class 'warp.types.float16'>], b: spatial_vector_t[<class 'warp.types.float16'>]) -> spatial_vector_t[<class 'warp.types.float16'>]

   Compute the dual cross-product of two 6d screw vectors.


.. function:: spatial_cross_dual(a: spatial_vector_t[~Float], b: spatial_vector_t[~Float]) -> spatial_vector_t[~Float]

   Compute the dual cross-product of two 6d screw vectors.


.. function:: spatial_top(a: spatial_vector_t[<class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Return the top (first) part of a 6d screw vector.


.. function:: spatial_top(a: spatial_vector_t[<class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the top (first) part of a 6d screw vector.


.. function:: spatial_top(a: spatial_vector_t[<class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the top (first) part of a 6d screw vector.


.. function:: spatial_top(a: spatial_vector_t[<class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Return the top (first) part of a 6d screw vector.


.. function:: spatial_top(a: spatial_vector_t[~Float])

   Return the top (first) part of a 6d screw vector.


.. function:: spatial_bottom(a: spatial_vector_t[<class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]

   Return the bottom (second) part of a 6d screw vector.


.. function:: spatial_bottom(a: spatial_vector_t[<class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the bottom (second) part of a 6d screw vector.


.. function:: spatial_bottom(a: spatial_vector_t[<class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Return the bottom (second) part of a 6d screw vector.


.. function:: spatial_bottom(a: spatial_vector_t[<class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]

   Return the bottom (second) part of a 6d screw vector.


.. function:: spatial_bottom(a: spatial_vector_t[~Float])

   Return the bottom (second) part of a 6d screw vector.


.. function:: spatial_jacobian(S: array[spatial_vector_t[~Float]], joint_parents: array[int32], joint_qd_start: array[int32], joint_start: int32, joint_count: int32, J_start: int32, J_out: array[Float]) -> None


.. function:: spatial_mass(I_s: array[spatial_matrix_t[~Float]], joint_start: int32, joint_count: int32, M_start: int32, M: array[Float]) -> None




Utility
---------------
.. function:: mlp(weights: array[float32], bias: array[float32], activation: Callable, index: int32, x: array[float32], out: array[float32]) -> None

   Evaluate a multi-layer perceptron (MLP) layer in the form: ``out = act(weights*x + bias)``. 

   :param weights: A layer's network weights with dimensions ``(m, n)``.
   :param bias: An array with dimensions ``(n)``.
   :param activation: A ``wp.func`` function that takes a single scalar float as input and returns a scalar float as output
   :param index: The batch item to process, typically each thread will process 1 item in the batch, in this case index should be ``wp.tid()``
   :param x: The feature matrix with dimensions ``(n, b)``
   :param out: The network output with dimensions ``(m, b)``

   :note: Feature and output matrices are transposed compared to some other frameworks such as PyTorch. All matrices are assumed to be stored in flattened row-major memory layout (NumPy default).


.. function:: printf() -> None

   Allows printing formatted strings, using C-style format specifiers.


.. function:: print(value: Any) -> None

   Print variable to stdout


.. function:: tid() -> int

   Return the current thread index. Note that this is the *global* index of the thread in the range [0, dim) 
   where dim is the parameter passed to kernel launch.


.. function:: tid() -> Tuple[int, int]

   Return the current thread indices for a 2d kernel launch. Use ``i,j = wp.tid()`` syntax to retrieve the coordinates inside the kernel thread grid.


.. function:: tid() -> Tuple[int, int, int]

   Return the current thread indices for a 3d kernel launch. Use ``i,j,k = wp.tid()`` syntax to retrieve the coordinates inside the kernel thread grid.


.. function:: tid() -> Tuple[int, int, int, int]

   Return the current thread indices for a 4d kernel launch. Use ``i,j,k,l = wp.tid()`` syntax to retrieve the coordinates inside the kernel thread grid.


.. function:: select(cond: bool, arg1: Any, arg2: Any)

   Select between two arguments, if cond is false then return ``arg1``, otherwise return ``arg2``


.. function:: atomic_add(a: array[Any], i: int32, value: Any)

   Atomically add ``value`` onto the array at location given by index.


.. function:: atomic_add(a: array[Any], i: int32, j: int32, value: Any)

   Atomically add ``value`` onto the array at location given by indices.


.. function:: atomic_add(a: array[Any], i: int32, j: int32, k: int32, value: Any)

   Atomically add ``value`` onto the array at location given by indices.


.. function:: atomic_add(a: array[Any], i: int32, j: int32, k: int32, l: int32, value: Any)

   Atomically add ``value`` onto the array at location given by indices.


.. function:: atomic_sub(a: array[Any], i: int32, value: Any)

   Atomically subtract ``value`` onto the array at location given by index.


.. function:: atomic_sub(a: array[Any], i: int32, j: int32, value: Any)

   Atomically subtract ``value`` onto the array at location given by indices.


.. function:: atomic_sub(a: array[Any], i: int32, j: int32, k: int32, value: Any)

   Atomically subtract ``value`` onto the array at location given by indices.


.. function:: atomic_sub(a: array[Any], i: int32, j: int32, k: int32, l: int32, value: Any)

   Atomically subtract ``value`` onto the array at location given by indices.


.. function:: atomic_min(a: array[Any], i: int32, value: Any)

   Compute the minimum of ``value`` and ``array[index]`` and atomically update the array. Note that for vectors and matrices the operation is only atomic on a per-component basis.


.. function:: atomic_min(a: array[Any], i: int32, j: int32, value: Any)

   Compute the minimum of ``value`` and ``array[index]`` and atomically update the array. Note that for vectors and matrices the operation is only atomic on a per-component basis.


.. function:: atomic_min(a: array[Any], i: int32, j: int32, k: int32, value: Any)

   Compute the minimum of ``value`` and ``array[index]`` and atomically update the array. Note that for vectors and matrices the operation is only atomic on a per-component basis.


.. function:: atomic_min(a: array[Any], i: int32, j: int32, k: int32, l: int32, value: Any)

   Compute the minimum of ``value`` and ``array[index]`` and atomically update the array. Note that for vectors and matrices the operation is only atomic on a per-component basis.


.. function:: atomic_max(a: array[Any], i: int32, value: Any)

   Compute the maximum of ``value`` and ``array[index]`` and atomically update the array. Note that for vectors and matrices the operation is only atomic on a per-component basis.


.. function:: atomic_max(a: array[Any], i: int32, j: int32, value: Any)

   Compute the maximum of ``value`` and ``array[index]`` and atomically update the array. Note that for vectors and matrices the operation is only atomic on a per-component basis.


.. function:: atomic_max(a: array[Any], i: int32, j: int32, k: int32, value: Any)

   Compute the maximum of ``value`` and ``array[index]`` and atomically update the array. Note that for vectors and matrices the operation is only atomic on a per-component basis.


.. function:: atomic_max(a: array[Any], i: int32, j: int32, k: int32, l: int32, value: Any)

   Compute the maximum of ``value`` and ``array[index]`` and atomically update the array. Note that for vectors and matrices the operation is only atomic on a per-component basis.


.. function:: expect_eq(arg1: int8, arg2: int8) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: uint8, arg2: uint8) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: int16, arg2: int16) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: uint16, arg2: uint16) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: int32, arg2: int32) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: uint32, arg2: uint32) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: int64, arg2: int64) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: uint64, arg2: uint64) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: float16, arg2: float16) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: float32, arg2: float32) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: float64, arg2: float64) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: quaternion[<class 'warp.types.float16'>], arg2: quaternion[<class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: quaternion[<class 'warp.types.float32'>], arg2: quaternion[<class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: quaternion[<class 'warp.types.float64'>], arg2: quaternion[<class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: quaternion[<class 'warp.types.float32'>], arg2: quaternion[<class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: transform_t[<class 'warp.types.float16'>], arg2: transform_t[<class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: transform_t[<class 'warp.types.float32'>], arg2: transform_t[<class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: transform_t[<class 'warp.types.float64'>], arg2: transform_t[<class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: transform_t[<class 'warp.types.float32'>], arg2: transform_t[<class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[2, <class 'warp.types.float64'>], arg2: vec[2, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[3, <class 'warp.types.float64'>], arg2: vec[3, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[4, <class 'warp.types.float64'>], arg2: vec[4, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[2, <class 'warp.types.float32'>], arg2: vec[2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[2, <class 'warp.types.float32'>], arg2: vec[2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[2, <class 'warp.types.float32'>], arg2: vec[2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[2, <class 'warp.types.float32'>], arg2: vec[2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[3, <class 'warp.types.float32'>], arg2: vec[3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[3, <class 'warp.types.float32'>], arg2: vec[3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[3, <class 'warp.types.float32'>], arg2: vec[3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[3, <class 'warp.types.float32'>], arg2: vec[3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[4, <class 'warp.types.float32'>], arg2: vec[4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[4, <class 'warp.types.float32'>], arg2: vec[4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[4, <class 'warp.types.float32'>], arg2: vec[4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[4, <class 'warp.types.float32'>], arg2: vec[4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[2, <class 'warp.types.uint8'>], arg2: vec[2, <class 'warp.types.uint8'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[3, <class 'warp.types.uint8'>], arg2: vec[3, <class 'warp.types.uint8'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[4, <class 'warp.types.uint8'>], arg2: vec[4, <class 'warp.types.uint8'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[2, <class 'warp.types.float16'>], arg2: vec[2, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[3, <class 'warp.types.float16'>], arg2: vec[3, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[4, <class 'warp.types.float16'>], arg2: vec[4, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: vec[typing.Any, ~Scalar], arg2: vec[typing.Any, ~Scalar])

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[2, 2, <class 'warp.types.float64'>], arg2: mat[2, 2, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[3, 3, <class 'warp.types.float64'>], arg2: mat[3, 3, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[4, 4, <class 'warp.types.float64'>], arg2: mat[4, 4, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[2, 2, <class 'warp.types.float32'>], arg2: mat[2, 2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[2, 2, <class 'warp.types.float32'>], arg2: mat[2, 2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[2, 2, <class 'warp.types.float32'>], arg2: mat[2, 2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[2, 2, <class 'warp.types.float32'>], arg2: mat[2, 2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[3, 3, <class 'warp.types.float32'>], arg2: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[3, 3, <class 'warp.types.float32'>], arg2: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[3, 3, <class 'warp.types.float32'>], arg2: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[3, 3, <class 'warp.types.float32'>], arg2: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[4, 4, <class 'warp.types.float32'>], arg2: mat[4, 4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[4, 4, <class 'warp.types.float32'>], arg2: mat[4, 4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[4, 4, <class 'warp.types.float32'>], arg2: mat[4, 4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[4, 4, <class 'warp.types.float32'>], arg2: mat[4, 4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[2, 2, <class 'warp.types.float16'>], arg2: mat[2, 2, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[3, 3, <class 'warp.types.float16'>], arg2: mat[3, 3, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[4, 4, <class 'warp.types.float16'>], arg2: mat[4, 4, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_eq(arg1: mat[typing.Any, typing.Any, ~Scalar], arg2: mat[typing.Any, typing.Any, ~Scalar])

   Prints an error to stdout if arg1 and arg2 are not equal


.. function:: expect_neq(arg1: vec[2, <class 'warp.types.float64'>], arg2: vec[2, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[3, <class 'warp.types.float64'>], arg2: vec[3, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[4, <class 'warp.types.float64'>], arg2: vec[4, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[2, <class 'warp.types.float32'>], arg2: vec[2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[2, <class 'warp.types.float32'>], arg2: vec[2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[2, <class 'warp.types.float32'>], arg2: vec[2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[2, <class 'warp.types.float32'>], arg2: vec[2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[3, <class 'warp.types.float32'>], arg2: vec[3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[3, <class 'warp.types.float32'>], arg2: vec[3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[3, <class 'warp.types.float32'>], arg2: vec[3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[3, <class 'warp.types.float32'>], arg2: vec[3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[4, <class 'warp.types.float32'>], arg2: vec[4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[4, <class 'warp.types.float32'>], arg2: vec[4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[4, <class 'warp.types.float32'>], arg2: vec[4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[4, <class 'warp.types.float32'>], arg2: vec[4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[2, <class 'warp.types.uint8'>], arg2: vec[2, <class 'warp.types.uint8'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[3, <class 'warp.types.uint8'>], arg2: vec[3, <class 'warp.types.uint8'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[4, <class 'warp.types.uint8'>], arg2: vec[4, <class 'warp.types.uint8'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[2, <class 'warp.types.float16'>], arg2: vec[2, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[3, <class 'warp.types.float16'>], arg2: vec[3, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[4, <class 'warp.types.float16'>], arg2: vec[4, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: vec[typing.Any, ~Scalar], arg2: vec[typing.Any, ~Scalar])

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[2, 2, <class 'warp.types.float64'>], arg2: mat[2, 2, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[3, 3, <class 'warp.types.float64'>], arg2: mat[3, 3, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[4, 4, <class 'warp.types.float64'>], arg2: mat[4, 4, <class 'warp.types.float64'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[2, 2, <class 'warp.types.float32'>], arg2: mat[2, 2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[2, 2, <class 'warp.types.float32'>], arg2: mat[2, 2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[2, 2, <class 'warp.types.float32'>], arg2: mat[2, 2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[2, 2, <class 'warp.types.float32'>], arg2: mat[2, 2, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[3, 3, <class 'warp.types.float32'>], arg2: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[3, 3, <class 'warp.types.float32'>], arg2: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[3, 3, <class 'warp.types.float32'>], arg2: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[3, 3, <class 'warp.types.float32'>], arg2: mat[3, 3, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[4, 4, <class 'warp.types.float32'>], arg2: mat[4, 4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[4, 4, <class 'warp.types.float32'>], arg2: mat[4, 4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[4, 4, <class 'warp.types.float32'>], arg2: mat[4, 4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[4, 4, <class 'warp.types.float32'>], arg2: mat[4, 4, <class 'warp.types.float32'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[2, 2, <class 'warp.types.float16'>], arg2: mat[2, 2, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[3, 3, <class 'warp.types.float16'>], arg2: mat[3, 3, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[4, 4, <class 'warp.types.float16'>], arg2: mat[4, 4, <class 'warp.types.float16'>]) -> None

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: expect_neq(arg1: mat[typing.Any, typing.Any, ~Scalar], arg2: mat[typing.Any, typing.Any, ~Scalar])

   Prints an error to stdout if arg1 and arg2 are equal


.. function:: lerp(a: float64, b: float64, t: float64) -> float64

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: float32, b: float32, t: float32) -> float32

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: float16, b: float16, t: float16) -> float16

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: Float, b: Float, t: Float) -> Float

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[2, <class 'warp.types.float16'>], b: vec[2, <class 'warp.types.float16'>], t: float16) -> vec[2, <class 'warp.types.float16'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[2, <class 'warp.types.float32'>], b: vec[2, <class 'warp.types.float32'>], t: float32) -> vec[2, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[2, <class 'warp.types.float64'>], b: vec[2, <class 'warp.types.float64'>], t: float64) -> vec[2, <class 'warp.types.float64'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[2, <class 'warp.types.float32'>], b: vec[2, <class 'warp.types.float32'>], t: float32) -> vec[2, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[3, <class 'warp.types.float16'>], b: vec[3, <class 'warp.types.float16'>], t: float16) -> vec[3, <class 'warp.types.float16'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[3, <class 'warp.types.float32'>], b: vec[3, <class 'warp.types.float32'>], t: float32) -> vec[3, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[3, <class 'warp.types.float64'>], b: vec[3, <class 'warp.types.float64'>], t: float64) -> vec[3, <class 'warp.types.float64'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[3, <class 'warp.types.float32'>], b: vec[3, <class 'warp.types.float32'>], t: float32) -> vec[3, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[4, <class 'warp.types.float16'>], b: vec[4, <class 'warp.types.float16'>], t: float16) -> vec[4, <class 'warp.types.float16'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[4, <class 'warp.types.float32'>], b: vec[4, <class 'warp.types.float32'>], t: float32) -> vec[4, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[4, <class 'warp.types.float64'>], b: vec[4, <class 'warp.types.float64'>], t: float64) -> vec[4, <class 'warp.types.float64'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: vec[4, <class 'warp.types.float32'>], b: vec[4, <class 'warp.types.float32'>], t: float32) -> vec[4, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[2, 2, <class 'warp.types.float16'>], b: mat[2, 2, <class 'warp.types.float16'>], t: float16) -> mat[2, 2, <class 'warp.types.float16'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[2, 2, <class 'warp.types.float32'>], b: mat[2, 2, <class 'warp.types.float32'>], t: float32) -> mat[2, 2, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[2, 2, <class 'warp.types.float64'>], b: mat[2, 2, <class 'warp.types.float64'>], t: float64) -> mat[2, 2, <class 'warp.types.float64'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[2, 2, <class 'warp.types.float32'>], b: mat[2, 2, <class 'warp.types.float32'>], t: float32) -> mat[2, 2, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[3, 3, <class 'warp.types.float16'>], b: mat[3, 3, <class 'warp.types.float16'>], t: float16) -> mat[3, 3, <class 'warp.types.float16'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[3, 3, <class 'warp.types.float32'>], b: mat[3, 3, <class 'warp.types.float32'>], t: float32) -> mat[3, 3, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[3, 3, <class 'warp.types.float64'>], b: mat[3, 3, <class 'warp.types.float64'>], t: float64) -> mat[3, 3, <class 'warp.types.float64'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[3, 3, <class 'warp.types.float32'>], b: mat[3, 3, <class 'warp.types.float32'>], t: float32) -> mat[3, 3, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[4, 4, <class 'warp.types.float16'>], b: mat[4, 4, <class 'warp.types.float16'>], t: float16) -> mat[4, 4, <class 'warp.types.float16'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[4, 4, <class 'warp.types.float32'>], b: mat[4, 4, <class 'warp.types.float32'>], t: float32) -> mat[4, 4, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[4, 4, <class 'warp.types.float64'>], b: mat[4, 4, <class 'warp.types.float64'>], t: float64) -> mat[4, 4, <class 'warp.types.float64'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: mat[4, 4, <class 'warp.types.float32'>], b: mat[4, 4, <class 'warp.types.float32'>], t: float32) -> mat[4, 4, <class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: quaternion[<class 'warp.types.float16'>], b: quaternion[<class 'warp.types.float16'>], t: float16) -> quaternion[<class 'warp.types.float16'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: quaternion[<class 'warp.types.float32'>], b: quaternion[<class 'warp.types.float32'>], t: float32) -> quaternion[<class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: quaternion[<class 'warp.types.float64'>], b: quaternion[<class 'warp.types.float64'>], t: float64) -> quaternion[<class 'warp.types.float64'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: quaternion[<class 'warp.types.float32'>], b: quaternion[<class 'warp.types.float32'>], t: float32) -> quaternion[<class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: transform_t[<class 'warp.types.float16'>], b: transform_t[<class 'warp.types.float16'>], t: float16) -> transform_t[<class 'warp.types.float16'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: transform_t[<class 'warp.types.float32'>], b: transform_t[<class 'warp.types.float32'>], t: float32) -> transform_t[<class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: transform_t[<class 'warp.types.float64'>], b: transform_t[<class 'warp.types.float64'>], t: float64) -> transform_t[<class 'warp.types.float64'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: transform_t[<class 'warp.types.float32'>], b: transform_t[<class 'warp.types.float32'>], t: float32) -> transform_t[<class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: spatial_vector_t[<class 'warp.types.float16'>], b: spatial_vector_t[<class 'warp.types.float16'>], t: float16) -> spatial_vector_t[<class 'warp.types.float16'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>], t: float32) -> spatial_vector_t[<class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: spatial_vector_t[<class 'warp.types.float64'>], b: spatial_vector_t[<class 'warp.types.float64'>], t: float64) -> spatial_vector_t[<class 'warp.types.float64'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: spatial_vector_t[<class 'warp.types.float32'>], b: spatial_vector_t[<class 'warp.types.float32'>], t: float32) -> spatial_vector_t[<class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: spatial_matrix_t[<class 'warp.types.float16'>], b: spatial_matrix_t[<class 'warp.types.float16'>], t: float16) -> spatial_matrix_t[<class 'warp.types.float16'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: spatial_matrix_t[<class 'warp.types.float32'>], b: spatial_matrix_t[<class 'warp.types.float32'>], t: float32) -> spatial_matrix_t[<class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: spatial_matrix_t[<class 'warp.types.float64'>], b: spatial_matrix_t[<class 'warp.types.float64'>], t: float64) -> spatial_matrix_t[<class 'warp.types.float64'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: lerp(a: spatial_matrix_t[<class 'warp.types.float32'>], b: spatial_matrix_t[<class 'warp.types.float32'>], t: float32) -> spatial_matrix_t[<class 'warp.types.float32'>]

   Linearly interpolate two values a and b using factor t, computed as ``a*(1-t) + b*t``


.. function:: smoothstep(edge0: float64, edge1: float64, x: float64) -> float64

   Smoothly interpolate between two values edge0 and edge1 using a factor x, and return a result between 0 and 1 using a cubic Hermite interpolation after clamping


.. function:: smoothstep(edge0: float32, edge1: float32, x: float32) -> float32

   Smoothly interpolate between two values edge0 and edge1 using a factor x, and return a result between 0 and 1 using a cubic Hermite interpolation after clamping


.. function:: smoothstep(edge0: float16, edge1: float16, x: float16) -> float16

   Smoothly interpolate between two values edge0 and edge1 using a factor x, and return a result between 0 and 1 using a cubic Hermite interpolation after clamping


.. function:: smoothstep(edge0: Float, edge1: Float, x: Float) -> Float

   Smoothly interpolate between two values edge0 and edge1 using a factor x, and return a result between 0 and 1 using a cubic Hermite interpolation after clamping


.. function:: expect_near(arg1: float64, arg2: float64, tolerance: float64) -> None

   Prints an error to stdout if arg1 and arg2 are not closer than tolerance in magnitude


.. function:: expect_near(arg1: float32, arg2: float32, tolerance: float32) -> None

   Prints an error to stdout if arg1 and arg2 are not closer than tolerance in magnitude


.. function:: expect_near(arg1: float16, arg2: float16, tolerance: float16) -> None

   Prints an error to stdout if arg1 and arg2 are not closer than tolerance in magnitude


.. function:: expect_near(arg1: Float, arg2: Float, tolerance: Float) -> None

   Prints an error to stdout if arg1 and arg2 are not closer than tolerance in magnitude


.. function:: expect_near(arg1: vec[3, <class 'warp.types.float32'>], arg2: vec[3, <class 'warp.types.float32'>], tolerance: float32) -> None

   Prints an error to stdout if any element of arg1 and arg2 are not closer than tolerance in magnitude




Geometry
---------------
.. function:: bvh_query_aabb(id: uint64, lower: vec[3, <class 'warp.types.float32'>], upper: vec[3, <class 'warp.types.float32'>]) -> bvh_query_t

   Construct an axis-aligned bounding box query against a bvh object. This query can be used to iterate over all bounds
   inside a bvh. Returns an object that is used to track state during bvh traversal.
    
   :param id: The bvh identifier
   :param lower: The lower bound of the bounding box in bvh space
   :param upper: The upper bound of the bounding box in bvh space


.. function:: bvh_query_ray(id: uint64, start: vec[3, <class 'warp.types.float32'>], dir: vec[3, <class 'warp.types.float32'>]) -> bvh_query_t

   Construct a ray query against a bvh object. This query can be used to iterate over all bounds
   that intersect the ray. Returns an object that is used to track state during bvh traversal.
    
   :param id: The bvh identifier
   :param start: The start of the ray in bvh space
   :param dir: The direction of the ray in bvh space


.. function:: bvh_query_next(query: bvh_query_t, index: int32) -> bool

   Move to the next bound returned by the query. The index of the current bound is stored in ``index``, returns ``False``
   if there are no more overlapping bound.


.. function:: mesh_query_point(id: uint64, point: vec[3, <class 'warp.types.float32'>], max_dist: float32, inside: float32, face: int32, bary_u: float32, bary_v: float32) -> bool

   Computes the closest point on the mesh with identifier `id` to the given point in space. Returns ``True`` if a point < ``max_dist`` is found.

   :param id: The mesh identifier
   :param point: The point in space to query
   :param max_dist: Mesh faces above this distance will not be considered by the query
   :param inside: Returns a value < 0 if query point is inside the mesh, >=0 otherwise. Note that mesh must be watertight for this to be robust
   :param face: Returns the index of the closest face
   :param bary_u: Returns the barycentric u coordinate of the closest point
   :param bary_v: Retruns the barycentric v coordinate of the closest point


.. function:: mesh_query_ray(id: uint64, start: vec[3, <class 'warp.types.float32'>], dir: vec[3, <class 'warp.types.float32'>], max_t: float32, t: float32, bary_u: float32, bary_v: float32, sign: float32, normal: vec[3, <class 'warp.types.float32'>], face: int32) -> bool

   Computes the closest ray hit on the mesh with identifier `id`, returns ``True`` if a point < ``max_t`` is found.

   :param id: The mesh identifier
   :param start: The start point of the ray
   :param dir: The ray direction (should be normalized)
   :param max_t: The maximum distance along the ray to check for intersections
   :param t: Returns the distance of the closest hit along the ray
   :param bary_u: Returns the barycentric u coordinate of the closest hit
   :param bary_v: Returns the barycentric v coordinate of the closest hit
   :param sign: Returns a value > 0 if the hit ray hit front of the face, returns < 0 otherwise
   :param normal: Returns the face normal
   :param face: Returns the index of the hit face


.. function:: mesh_query_aabb(id: uint64, lower: vec[3, <class 'warp.types.float32'>], upper: vec[3, <class 'warp.types.float32'>]) -> mesh_query_aabb_t

   Construct an axis-aligned bounding box query against a mesh object. This query can be used to iterate over all triangles
   inside a volume. Returns an object that is used to track state during mesh traversal.
    
   :param id: The mesh identifier
   :param lower: The lower bound of the bounding box in mesh space
   :param upper: The upper bound of the bounding box in mesh space


.. function:: mesh_query_aabb_next(query: mesh_query_aabb_t, index: int32) -> bool

   Move to the next triangle overlapping the query bounding box. The index of the current face is stored in ``index``, returns ``False``
   if there are no more overlapping triangles.


.. function:: mesh_eval_position(id: uint64, face: int32, bary_u: float32, bary_v: float32) -> vec[3, <class 'warp.types.float32'>]

   Evaluates the position on the mesh given a face index, and barycentric coordinates.


.. function:: mesh_eval_velocity(id: uint64, face: int32, bary_u: float32, bary_v: float32) -> vec[3, <class 'warp.types.float32'>]

   Evaluates the velocity on the mesh given a face index, and barycentric coordinates.


.. function:: hash_grid_query(id: uint64, point: vec[3, <class 'warp.types.float32'>], max_dist: float32) -> hash_grid_query_t

   Construct a point query against a hash grid. This query can be used to iterate over all neighboring points withing a 
   fixed radius from the query point. Returns an object that is used to track state during neighbor traversal.


.. function:: hash_grid_query_next(query: hash_grid_query_t, index: int32) -> bool

   Move to the next point in the hash grid query. The index of the current neighbor is stored in ``index``, returns ``False``
   if there are no more neighbors.


.. function:: hash_grid_point_id(id: uint64, index: int32) -> int

   Return the index of a point in the grid, this can be used to re-order threads such that grid 
   traversal occurs in a spatially coherent order.


.. function:: intersect_tri_tri(v0: vec[3, <class 'warp.types.float32'>], v1: vec[3, <class 'warp.types.float32'>], v2: vec[3, <class 'warp.types.float32'>], u0: vec[3, <class 'warp.types.float32'>], u1: vec[3, <class 'warp.types.float32'>], u2: vec[3, <class 'warp.types.float32'>]) -> int

   Tests for intersection between two triangles (v0, v1, v2) and (u0, u1, u2) using Moller's method. Returns > 0 if triangles intersect.


.. function:: mesh_get(id: uint64) -> Mesh

   Retrieves the mesh given its index.


.. function:: mesh_eval_face_normal(id: uint64, face: int32) -> vec[3, <class 'warp.types.float32'>]

   Evaluates the face normal the mesh given a face index.


.. function:: mesh_get_point(id: uint64, index: int32) -> vec[3, <class 'warp.types.float32'>]

   Returns the point of the mesh given a index.


.. function:: mesh_get_velocity(id: uint64, index: int32) -> vec[3, <class 'warp.types.float32'>]

   Returns the velocity of the mesh given a index.


.. function:: mesh_get_index(id: uint64, index: int32) -> int

   Returns the point-index of the mesh given a face-vertex index.


.. function:: closest_point_edge_edge(p1: vec[3, <class 'warp.types.float32'>], q1: vec[3, <class 'warp.types.float32'>], p2: vec[3, <class 'warp.types.float32'>], q2: vec[3, <class 'warp.types.float32'>], epsilon: float32) -> vec[3, <class 'warp.types.float32'>]

   Finds the closest points between two edges. Returns barycentric weights to the points on each edge, as well as the closest distance between the edges.

   :param p1: First point of first edge
   :param q1: Second point of first edge
   :param p2: First point of second edge
   :param q2: Second point of second edge
   :param epsilon: Zero tolerance for determining if points in an edge are degenerate.
   :param out: vec3 output containing (s,t,d), where `s` in [0,1] is the barycentric weight for the first edge, `t` is the barycentric weight for the second edge, and `d` is the distance between the two edges at these two closest points.




Volumes
---------------
.. function:: volume_sample_f(id: uint64, uvw: vec[3, <class 'warp.types.float32'>], sampling_mode: int32) -> float

   Sample the volume given by ``id`` at the volume local-space point ``uvw``. Interpolation should be ``wp.Volume.CLOSEST``, or ``wp.Volume.LINEAR.``


.. function:: volume_lookup_f(id: uint64, i: int32, j: int32, k: int32) -> float

   Returns the value of voxel with coordinates ``i``, ``j``, ``k``, if the voxel at this index does not exist this function returns the background value


.. function:: volume_store_f(id: uint64, i: int32, j: int32, k: int32, value: float32) -> None

   Store the value at voxel with coordinates ``i``, ``j``, ``k``.


.. function:: volume_sample_v(id: uint64, uvw: vec[3, <class 'warp.types.float32'>], sampling_mode: int32) -> vec[3, <class 'warp.types.float32'>]

   Sample the vector volume given by ``id`` at the volume local-space point ``uvw``. Interpolation should be ``wp.Volume.CLOSEST``, or ``wp.Volume.LINEAR.``


.. function:: volume_lookup_v(id: uint64, i: int32, j: int32, k: int32) -> vec[3, <class 'warp.types.float32'>]

   Returns the vector value of voxel with coordinates ``i``, ``j``, ``k``, if the voxel at this index does not exist this function returns the background value


.. function:: volume_store_v(id: uint64, i: int32, j: int32, k: int32, value: vec[3, <class 'warp.types.float32'>]) -> None

   Store the value at voxel with coordinates ``i``, ``j``, ``k``.


.. function:: volume_sample_i(id: uint64, uvw: vec[3, <class 'warp.types.float32'>]) -> int

   Sample the int32 volume given by ``id`` at the volume local-space point ``uvw``. 


.. function:: volume_lookup_i(id: uint64, i: int32, j: int32, k: int32) -> int

   Returns the int32 value of voxel with coordinates ``i``, ``j``, ``k``, if the voxel at this index does not exist this function returns the background value


.. function:: volume_store_i(id: uint64, i: int32, j: int32, k: int32, value: int32) -> None

   Store the value at voxel with coordinates ``i``, ``j``, ``k``.


.. function:: volume_index_to_world(id: uint64, uvw: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Transform a point defined in volume index space to world space given the volume's intrinsic affine transformation.


.. function:: volume_world_to_index(id: uint64, xyz: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Transform a point defined in volume world space to the volume's index space, given the volume's intrinsic affine transformation.


.. function:: volume_index_to_world_dir(id: uint64, uvw: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Transform a direction defined in volume index space to world space given the volume's intrinsic affine transformation.


.. function:: volume_world_to_index_dir(id: uint64, xyz: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Transform a direction defined in volume world space to the volume's index space, given the volume's intrinsic affine transformation.




Random
---------------
.. function:: rand_init(seed: int32) -> uint32

   Initialize a new random number generator given a user-defined seed. Returns a 32-bit integer representing the RNG state.


.. function:: rand_init(seed: int32, offset: int32) -> uint32

   Initialize a new random number generator given a user-defined seed and an offset. 
   This alternative constructor can be useful in parallel programs, where a kernel as a whole should share a seed,
   but each thread should generate uncorrelated values. In this case usage should be ``r = rand_init(seed, tid)``


.. function:: randi(state: uint32) -> int

   Return a random integer between [0, 2^32)


.. function:: randi(state: uint32, min: int32, max: int32) -> int

   Return a random integer between [min, max)


.. function:: randf(state: uint32) -> float

   Return a random float between [0.0, 1.0)


.. function:: randf(state: uint32, min: float32, max: float32) -> float

   Return a random float between [min, max)


.. function:: randn(state: uint32) -> float

   Sample a normal distribution


.. function:: sample_cdf(state: uint32, cdf: array[float32]) -> int

   Inverse transform sample a cumulative distribution function


.. function:: sample_triangle(state: uint32) -> vec[2, <class 'warp.types.float32'>]

   Uniformly sample a triangle. Returns sample barycentric coordinates


.. function:: sample_unit_ring(state: uint32) -> vec[2, <class 'warp.types.float32'>]

   Uniformly sample a ring in the xy plane


.. function:: sample_unit_disk(state: uint32) -> vec[2, <class 'warp.types.float32'>]

   Uniformly sample a disk in the xy plane


.. function:: sample_unit_sphere_surface(state: uint32) -> vec[3, <class 'warp.types.float32'>]

   Uniformly sample a unit sphere surface


.. function:: sample_unit_sphere(state: uint32) -> vec[3, <class 'warp.types.float32'>]

   Uniformly sample a unit sphere


.. function:: sample_unit_hemisphere_surface(state: uint32) -> vec[3, <class 'warp.types.float32'>]

   Uniformly sample a unit hemisphere surface


.. function:: sample_unit_hemisphere(state: uint32) -> vec[3, <class 'warp.types.float32'>]

   Uniformly sample a unit hemisphere


.. function:: sample_unit_square(state: uint32) -> vec[2, <class 'warp.types.float32'>]

   Uniformly sample a unit square


.. function:: sample_unit_cube(state: uint32) -> vec[3, <class 'warp.types.float32'>]

   Uniformly sample a unit cube


.. function:: noise(state: uint32, x: float32) -> float

   Non-periodic Perlin-style noise in 1d.


.. function:: noise(state: uint32, xy: vec[2, <class 'warp.types.float32'>]) -> float

   Non-periodic Perlin-style noise in 2d.


.. function:: noise(state: uint32, xyz: vec[3, <class 'warp.types.float32'>]) -> float

   Non-periodic Perlin-style noise in 3d.


.. function:: noise(state: uint32, xyzt: vec[4, <class 'warp.types.float32'>]) -> float

   Non-periodic Perlin-style noise in 4d.


.. function:: pnoise(state: uint32, x: float32, px: int32) -> float

   Periodic Perlin-style noise in 1d.


.. function:: pnoise(state: uint32, xy: vec[2, <class 'warp.types.float32'>], px: int32, py: int32) -> float

   Periodic Perlin-style noise in 2d.


.. function:: pnoise(state: uint32, xyz: vec[3, <class 'warp.types.float32'>], px: int32, py: int32, pz: int32) -> float

   Periodic Perlin-style noise in 3d.


.. function:: pnoise(state: uint32, xyzt: vec[4, <class 'warp.types.float32'>], px: int32, py: int32, pz: int32, pt: int32) -> float

   Periodic Perlin-style noise in 4d.


.. function:: curlnoise(state: uint32, xy: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]

   Divergence-free vector field based on the gradient of a Perlin noise function. [1]_


.. function:: curlnoise(state: uint32, xyz: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Divergence-free vector field based on the curl of three Perlin noise functions. [1]_


.. function:: curlnoise(state: uint32, xyzt: vec[4, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]

   Divergence-free vector field based on the curl of three Perlin noise functions. [1]_




Other
---------------
.. function:: lower_bound(arr: array[Scalar], value: uint32) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: int16) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: float64) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: int8) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: float16) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: uint16) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: int32) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: uint64) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: float32) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: int64) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: uint8) -> int

   Search a sorted array for the closest element greater than or equal to value.


.. function:: lower_bound(arr: array[Scalar], value: Scalar) -> int

   Search a sorted array for the closest element greater than or equal to value.




Operators
---------------
.. function:: add(x: uint32, y: uint32) -> uint32


.. function:: add(x: int16, y: int16) -> int16


.. function:: add(x: float64, y: float64) -> float64


.. function:: add(x: int8, y: int8) -> int8


.. function:: add(x: float16, y: float16) -> float16


.. function:: add(x: uint16, y: uint16) -> uint16


.. function:: add(x: int32, y: int32) -> int32


.. function:: add(x: uint64, y: uint64) -> uint64


.. function:: add(x: float32, y: float32) -> float32


.. function:: add(x: int64, y: int64) -> int64


.. function:: add(x: uint8, y: uint8) -> uint8


.. function:: add(x: Scalar, y: Scalar) -> Scalar


.. function:: add(x: vec[2, <class 'warp.types.float64'>], y: vec[2, <class 'warp.types.float64'>]) -> vec[2, <class 'warp.types.float64'>]


.. function:: add(x: vec[3, <class 'warp.types.float64'>], y: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]


.. function:: add(x: vec[4, <class 'warp.types.float64'>], y: vec[4, <class 'warp.types.float64'>]) -> vec[4, <class 'warp.types.float64'>]


.. function:: add(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: add(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: add(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: add(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: add(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: add(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: add(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: add(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: add(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: add(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: add(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: add(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: add(x: vec[2, <class 'warp.types.uint8'>], y: vec[2, <class 'warp.types.uint8'>]) -> vec[2, <class 'warp.types.uint8'>]


.. function:: add(x: vec[3, <class 'warp.types.uint8'>], y: vec[3, <class 'warp.types.uint8'>]) -> vec[3, <class 'warp.types.uint8'>]


.. function:: add(x: vec[4, <class 'warp.types.uint8'>], y: vec[4, <class 'warp.types.uint8'>]) -> vec[4, <class 'warp.types.uint8'>]


.. function:: add(x: vec[2, <class 'warp.types.float16'>], y: vec[2, <class 'warp.types.float16'>]) -> vec[2, <class 'warp.types.float16'>]


.. function:: add(x: vec[3, <class 'warp.types.float16'>], y: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]


.. function:: add(x: vec[4, <class 'warp.types.float16'>], y: vec[4, <class 'warp.types.float16'>]) -> vec[4, <class 'warp.types.float16'>]


.. function:: add(x: vec[typing.Any, ~Scalar], y: vec[typing.Any, ~Scalar]) -> vec[typing.Any, ~Scalar]


.. function:: add(x: quaternion[<class 'warp.types.float64'>], y: quaternion[<class 'warp.types.float64'>]) -> quaternion[<class 'warp.types.float64'>]


.. function:: add(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: add(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: add(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: add(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: add(x: quaternion[<class 'warp.types.float16'>], y: quaternion[<class 'warp.types.float16'>]) -> quaternion[<class 'warp.types.float16'>]


.. function:: add(x: quaternion[~Scalar], y: quaternion[~Scalar]) -> quaternion[~Scalar]


.. function:: add(x: mat[2, 2, <class 'warp.types.float64'>], y: mat[2, 2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]


.. function:: add(x: mat[3, 3, <class 'warp.types.float64'>], y: mat[3, 3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]


.. function:: add(x: mat[4, 4, <class 'warp.types.float64'>], y: mat[4, 4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]


.. function:: add(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: add(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: add(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: add(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: add(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: add(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: add(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: add(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: add(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: add(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: add(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: add(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: add(x: mat[2, 2, <class 'warp.types.float16'>], y: mat[2, 2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]


.. function:: add(x: mat[3, 3, <class 'warp.types.float16'>], y: mat[3, 3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]


.. function:: add(x: mat[4, 4, <class 'warp.types.float16'>], y: mat[4, 4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]


.. function:: add(x: mat[typing.Any, typing.Any, ~Scalar], y: mat[typing.Any, typing.Any, ~Scalar]) -> mat[typing.Any, typing.Any, ~Scalar]


.. function:: add(x: spatial_vector_t[<class 'warp.types.float64'>], y: spatial_vector_t[<class 'warp.types.float64'>]) -> spatial_vector_t[<class 'warp.types.float64'>]


.. function:: add(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: add(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: add(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: add(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: add(x: spatial_vector_t[<class 'warp.types.float16'>], y: spatial_vector_t[<class 'warp.types.float16'>]) -> spatial_vector_t[<class 'warp.types.float16'>]


.. function:: add(x: spatial_vector_t[~Scalar], y: spatial_vector_t[~Scalar]) -> spatial_vector_t[~Scalar]


.. function:: add(x: spatial_matrix_t[<class 'warp.types.float64'>], y: spatial_matrix_t[<class 'warp.types.float64'>]) -> spatial_matrix_t[<class 'warp.types.float64'>]


.. function:: add(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: add(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: add(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: add(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: add(x: spatial_matrix_t[<class 'warp.types.float16'>], y: spatial_matrix_t[<class 'warp.types.float16'>]) -> spatial_matrix_t[<class 'warp.types.float16'>]


.. function:: add(x: spatial_matrix_t[~Scalar], y: spatial_matrix_t[~Scalar]) -> spatial_matrix_t[~Scalar]


.. function:: add(x: transform_t[<class 'warp.types.float64'>], y: transform_t[<class 'warp.types.float64'>]) -> transform_t[<class 'warp.types.float64'>]


.. function:: add(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: add(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: add(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: add(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: add(x: transform_t[<class 'warp.types.float16'>], y: transform_t[<class 'warp.types.float16'>]) -> transform_t[<class 'warp.types.float16'>]


.. function:: add(x: transform_t[~Scalar], y: transform_t[~Scalar]) -> transform_t[~Scalar]


.. function:: sub(x: uint32, y: uint32) -> uint32


.. function:: sub(x: int16, y: int16) -> int16


.. function:: sub(x: float64, y: float64) -> float64


.. function:: sub(x: int8, y: int8) -> int8


.. function:: sub(x: float16, y: float16) -> float16


.. function:: sub(x: uint16, y: uint16) -> uint16


.. function:: sub(x: int32, y: int32) -> int32


.. function:: sub(x: uint64, y: uint64) -> uint64


.. function:: sub(x: float32, y: float32) -> float32


.. function:: sub(x: int64, y: int64) -> int64


.. function:: sub(x: uint8, y: uint8) -> uint8


.. function:: sub(x: Scalar, y: Scalar) -> Scalar


.. function:: sub(x: vec[2, <class 'warp.types.float64'>], y: vec[2, <class 'warp.types.float64'>]) -> vec[2, <class 'warp.types.float64'>]


.. function:: sub(x: vec[3, <class 'warp.types.float64'>], y: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]


.. function:: sub(x: vec[4, <class 'warp.types.float64'>], y: vec[4, <class 'warp.types.float64'>]) -> vec[4, <class 'warp.types.float64'>]


.. function:: sub(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: sub(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: sub(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: sub(x: vec[2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: sub(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: sub(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: sub(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: sub(x: vec[3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: sub(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: sub(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: sub(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: sub(x: vec[4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: sub(x: vec[2, <class 'warp.types.uint8'>], y: vec[2, <class 'warp.types.uint8'>]) -> vec[2, <class 'warp.types.uint8'>]


.. function:: sub(x: vec[3, <class 'warp.types.uint8'>], y: vec[3, <class 'warp.types.uint8'>]) -> vec[3, <class 'warp.types.uint8'>]


.. function:: sub(x: vec[4, <class 'warp.types.uint8'>], y: vec[4, <class 'warp.types.uint8'>]) -> vec[4, <class 'warp.types.uint8'>]


.. function:: sub(x: vec[2, <class 'warp.types.float16'>], y: vec[2, <class 'warp.types.float16'>]) -> vec[2, <class 'warp.types.float16'>]


.. function:: sub(x: vec[3, <class 'warp.types.float16'>], y: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]


.. function:: sub(x: vec[4, <class 'warp.types.float16'>], y: vec[4, <class 'warp.types.float16'>]) -> vec[4, <class 'warp.types.float16'>]


.. function:: sub(x: vec[typing.Any, ~Scalar], y: vec[typing.Any, ~Scalar]) -> vec[typing.Any, ~Scalar]


.. function:: sub(x: mat[2, 2, <class 'warp.types.float64'>], y: mat[2, 2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]


.. function:: sub(x: mat[3, 3, <class 'warp.types.float64'>], y: mat[3, 3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]


.. function:: sub(x: mat[4, 4, <class 'warp.types.float64'>], y: mat[4, 4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]


.. function:: sub(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: sub(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: sub(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: sub(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: sub(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: sub(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: sub(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: sub(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: sub(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: sub(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: sub(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: sub(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: sub(x: mat[2, 2, <class 'warp.types.float16'>], y: mat[2, 2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]


.. function:: sub(x: mat[3, 3, <class 'warp.types.float16'>], y: mat[3, 3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]


.. function:: sub(x: mat[4, 4, <class 'warp.types.float16'>], y: mat[4, 4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]


.. function:: sub(x: mat[typing.Any, typing.Any, ~Scalar], y: mat[typing.Any, typing.Any, ~Scalar]) -> mat[typing.Any, typing.Any, ~Scalar]


.. function:: sub(x: spatial_vector_t[<class 'warp.types.float64'>], y: spatial_vector_t[<class 'warp.types.float64'>]) -> spatial_vector_t[<class 'warp.types.float64'>]


.. function:: sub(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: sub(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: sub(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: sub(x: spatial_vector_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: sub(x: spatial_vector_t[<class 'warp.types.float16'>], y: spatial_vector_t[<class 'warp.types.float16'>]) -> spatial_vector_t[<class 'warp.types.float16'>]


.. function:: sub(x: spatial_vector_t[~Scalar], y: spatial_vector_t[~Scalar]) -> spatial_vector_t[~Scalar]


.. function:: sub(x: spatial_matrix_t[<class 'warp.types.float64'>], y: spatial_matrix_t[<class 'warp.types.float64'>]) -> spatial_matrix_t[<class 'warp.types.float64'>]


.. function:: sub(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: sub(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: sub(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: sub(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: sub(x: spatial_matrix_t[<class 'warp.types.float16'>], y: spatial_matrix_t[<class 'warp.types.float16'>]) -> spatial_matrix_t[<class 'warp.types.float16'>]


.. function:: sub(x: spatial_matrix_t[~Scalar], y: spatial_matrix_t[~Scalar]) -> spatial_matrix_t[~Scalar]


.. function:: sub(x: quaternion[<class 'warp.types.float64'>], y: quaternion[<class 'warp.types.float64'>]) -> quaternion[<class 'warp.types.float64'>]


.. function:: sub(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: sub(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: sub(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: sub(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: sub(x: quaternion[<class 'warp.types.float16'>], y: quaternion[<class 'warp.types.float16'>]) -> quaternion[<class 'warp.types.float16'>]


.. function:: sub(x: quaternion[~Scalar], y: quaternion[~Scalar]) -> quaternion[~Scalar]


.. function:: sub(x: transform_t[<class 'warp.types.float64'>], y: transform_t[<class 'warp.types.float64'>]) -> transform_t[<class 'warp.types.float64'>]


.. function:: sub(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: sub(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: sub(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: sub(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: sub(x: transform_t[<class 'warp.types.float16'>], y: transform_t[<class 'warp.types.float16'>]) -> transform_t[<class 'warp.types.float16'>]


.. function:: sub(x: transform_t[~Scalar], y: transform_t[~Scalar]) -> transform_t[~Scalar]


.. function:: mul(x: uint32, y: uint32) -> uint32


.. function:: mul(x: int16, y: int16) -> int16


.. function:: mul(x: float64, y: float64) -> float64


.. function:: mul(x: int8, y: int8) -> int8


.. function:: mul(x: float16, y: float16) -> float16


.. function:: mul(x: uint16, y: uint16) -> uint16


.. function:: mul(x: int32, y: int32) -> int32


.. function:: mul(x: uint64, y: uint64) -> uint64


.. function:: mul(x: float32, y: float32) -> float32


.. function:: mul(x: int64, y: int64) -> int64


.. function:: mul(x: uint8, y: uint8) -> uint8


.. function:: mul(x: Scalar, y: Scalar) -> Scalar


.. function:: mul(x: vec[2, <class 'warp.types.float64'>], y: float64) -> vec[2, <class 'warp.types.float64'>]


.. function:: mul(x: vec[3, <class 'warp.types.float64'>], y: float64) -> vec[3, <class 'warp.types.float64'>]


.. function:: mul(x: vec[4, <class 'warp.types.float64'>], y: float64) -> vec[4, <class 'warp.types.float64'>]


.. function:: mul(x: vec[2, <class 'warp.types.float16'>], y: float16) -> vec[2, <class 'warp.types.float16'>]


.. function:: mul(x: vec[3, <class 'warp.types.float16'>], y: float16) -> vec[3, <class 'warp.types.float16'>]


.. function:: mul(x: vec[4, <class 'warp.types.float16'>], y: float16) -> vec[4, <class 'warp.types.float16'>]


.. function:: mul(x: vec[2, <class 'warp.types.uint8'>], y: uint8) -> vec[2, <class 'warp.types.uint8'>]


.. function:: mul(x: vec[3, <class 'warp.types.uint8'>], y: uint8) -> vec[3, <class 'warp.types.uint8'>]


.. function:: mul(x: vec[4, <class 'warp.types.uint8'>], y: uint8) -> vec[4, <class 'warp.types.uint8'>]


.. function:: mul(x: vec[2, <class 'warp.types.float32'>], y: float32) -> vec[2, <class 'warp.types.float32'>]


.. function:: mul(x: vec[2, <class 'warp.types.float32'>], y: float32) -> vec[2, <class 'warp.types.float32'>]


.. function:: mul(x: vec[3, <class 'warp.types.float32'>], y: float32) -> vec[3, <class 'warp.types.float32'>]


.. function:: mul(x: vec[3, <class 'warp.types.float32'>], y: float32) -> vec[3, <class 'warp.types.float32'>]


.. function:: mul(x: vec[4, <class 'warp.types.float32'>], y: float32) -> vec[4, <class 'warp.types.float32'>]


.. function:: mul(x: vec[4, <class 'warp.types.float32'>], y: float32) -> vec[4, <class 'warp.types.float32'>]


.. function:: mul(x: vec[typing.Any, ~Scalar], y: Scalar) -> vec[typing.Any, ~Scalar]


.. function:: mul(x: float64, y: vec[2, <class 'warp.types.float64'>]) -> vec[2, <class 'warp.types.float64'>]


.. function:: mul(x: float64, y: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]


.. function:: mul(x: float64, y: vec[4, <class 'warp.types.float64'>]) -> vec[4, <class 'warp.types.float64'>]


.. function:: mul(x: float16, y: vec[2, <class 'warp.types.float16'>]) -> vec[2, <class 'warp.types.float16'>]


.. function:: mul(x: float16, y: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]


.. function:: mul(x: float16, y: vec[4, <class 'warp.types.float16'>]) -> vec[4, <class 'warp.types.float16'>]


.. function:: mul(x: uint8, y: vec[2, <class 'warp.types.uint8'>]) -> vec[2, <class 'warp.types.uint8'>]


.. function:: mul(x: uint8, y: vec[3, <class 'warp.types.uint8'>]) -> vec[3, <class 'warp.types.uint8'>]


.. function:: mul(x: uint8, y: vec[4, <class 'warp.types.uint8'>]) -> vec[4, <class 'warp.types.uint8'>]


.. function:: mul(x: float32, y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: mul(x: float32, y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: mul(x: float32, y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: mul(x: float32, y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: mul(x: float32, y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: mul(x: float32, y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: mul(x: Scalar, y: vec[typing.Any, ~Scalar]) -> vec[typing.Any, ~Scalar]


.. function:: mul(x: quaternion[<class 'warp.types.float64'>], y: float64) -> quaternion[<class 'warp.types.float64'>]


.. function:: mul(x: quaternion[<class 'warp.types.float16'>], y: float16) -> quaternion[<class 'warp.types.float16'>]


.. function:: mul(x: quaternion[<class 'warp.types.float32'>], y: float32) -> quaternion[<class 'warp.types.float32'>]


.. function:: mul(x: quaternion[<class 'warp.types.float32'>], y: float32) -> quaternion[<class 'warp.types.float32'>]


.. function:: mul(x: quaternion[~Scalar], y: Scalar) -> quaternion[~Scalar]


.. function:: mul(x: float64, y: quaternion[<class 'warp.types.float64'>]) -> quaternion[<class 'warp.types.float64'>]


.. function:: mul(x: float16, y: quaternion[<class 'warp.types.float16'>]) -> quaternion[<class 'warp.types.float16'>]


.. function:: mul(x: float32, y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: mul(x: float32, y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: mul(x: Scalar, y: quaternion[~Scalar]) -> quaternion[~Scalar]


.. function:: mul(x: quaternion[<class 'warp.types.float64'>], y: quaternion[<class 'warp.types.float64'>]) -> quaternion[<class 'warp.types.float64'>]


.. function:: mul(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: mul(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: mul(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: mul(x: quaternion[<class 'warp.types.float32'>], y: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: mul(x: quaternion[<class 'warp.types.float16'>], y: quaternion[<class 'warp.types.float16'>]) -> quaternion[<class 'warp.types.float16'>]


.. function:: mul(x: quaternion[~Scalar], y: quaternion[~Scalar]) -> quaternion[~Scalar]


.. function:: mul(x: float64, y: mat[2, 2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]


.. function:: mul(x: float64, y: mat[3, 3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]


.. function:: mul(x: float64, y: mat[4, 4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]


.. function:: mul(x: float16, y: mat[2, 2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]


.. function:: mul(x: float16, y: mat[3, 3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]


.. function:: mul(x: float16, y: mat[4, 4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]


.. function:: mul(x: float32, y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: mul(x: float32, y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: mul(x: float32, y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: mul(x: float32, y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: mul(x: float32, y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: mul(x: float32, y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: mul(x: Scalar, y: mat[typing.Any, typing.Any, ~Scalar]) -> mat[typing.Any, typing.Any, ~Scalar]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float64'>], y: float64) -> mat[2, 2, <class 'warp.types.float64'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float64'>], y: float64) -> mat[3, 3, <class 'warp.types.float64'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float64'>], y: float64) -> mat[4, 4, <class 'warp.types.float64'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float16'>], y: float16) -> mat[2, 2, <class 'warp.types.float16'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float16'>], y: float16) -> mat[3, 3, <class 'warp.types.float16'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float16'>], y: float16) -> mat[4, 4, <class 'warp.types.float16'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float32'>], y: float32) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float32'>], y: float32) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float32'>], y: float32) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float32'>], y: float32) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float32'>], y: float32) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float32'>], y: float32) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: mul(x: mat[typing.Any, typing.Any, ~Scalar], y: Scalar) -> mat[typing.Any, typing.Any, ~Scalar]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float64'>], y: vec[2, <class 'warp.types.float64'>]) -> vec[2, <class 'warp.types.float64'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float64'>], y: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float64'>], y: vec[4, <class 'warp.types.float64'>]) -> vec[4, <class 'warp.types.float64'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float16'>], y: vec[2, <class 'warp.types.float16'>]) -> vec[2, <class 'warp.types.float16'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float16'>], y: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float16'>], y: vec[4, <class 'warp.types.float16'>]) -> vec[4, <class 'warp.types.float16'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float32'>], y: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float32'>], y: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float32'>], y: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: mul(x: mat[typing.Any, typing.Any, ~Scalar], y: vec[typing.Any, ~Scalar]) -> vec[typing.Any, ~Scalar]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float64'>], y: mat[2, 2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float64'>], y: mat[3, 3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float64'>], y: mat[4, 4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float32'>], y: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float32'>], y: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float32'>], y: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: mul(x: mat[2, 2, <class 'warp.types.float16'>], y: mat[2, 2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]


.. function:: mul(x: mat[3, 3, <class 'warp.types.float16'>], y: mat[3, 3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]


.. function:: mul(x: mat[4, 4, <class 'warp.types.float16'>], y: mat[4, 4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]


.. function:: mul(x: mat[typing.Any, typing.Any, ~Scalar], y: mat[typing.Any, typing.Any, ~Scalar])


.. function:: mul(x: spatial_vector_t[<class 'warp.types.float64'>], y: float64) -> spatial_vector_t[<class 'warp.types.float64'>]


.. function:: mul(x: spatial_vector_t[<class 'warp.types.float16'>], y: float16) -> spatial_vector_t[<class 'warp.types.float16'>]


.. function:: mul(x: spatial_vector_t[<class 'warp.types.float32'>], y: float32) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_vector_t[<class 'warp.types.float32'>], y: float32) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_vector_t[~Scalar], y: Scalar) -> spatial_vector_t[~Scalar]


.. function:: mul(x: float64, y: spatial_vector_t[<class 'warp.types.float64'>]) -> spatial_vector_t[<class 'warp.types.float64'>]


.. function:: mul(x: float16, y: spatial_vector_t[<class 'warp.types.float16'>]) -> spatial_vector_t[<class 'warp.types.float16'>]


.. function:: mul(x: float32, y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: mul(x: float32, y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: mul(x: Scalar, y: spatial_vector_t[~Scalar]) -> spatial_vector_t[~Scalar]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float64'>], y: spatial_matrix_t[<class 'warp.types.float64'>]) -> spatial_matrix_t[<class 'warp.types.float64'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float16'>], y: spatial_matrix_t[<class 'warp.types.float16'>]) -> spatial_matrix_t[<class 'warp.types.float16'>]


.. function:: mul(x: spatial_matrix_t[~Scalar], y: spatial_matrix_t[~Scalar]) -> spatial_matrix_t[~Scalar]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float64'>], y: spatial_vector_t[<class 'warp.types.float64'>]) -> spatial_vector_t[<class 'warp.types.float64'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float16'>], y: spatial_vector_t[<class 'warp.types.float16'>]) -> spatial_vector_t[<class 'warp.types.float16'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float32'>], y: spatial_vector_t[<class 'warp.types.float32'>]) -> spatial_vector_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_matrix_t[~Scalar], y: spatial_vector_t[~Scalar]) -> spatial_vector_t[~Scalar]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float64'>], y: float64) -> spatial_matrix_t[<class 'warp.types.float64'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float16'>], y: float16) -> spatial_matrix_t[<class 'warp.types.float16'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float32'>], y: float32) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_matrix_t[<class 'warp.types.float32'>], y: float32) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: mul(x: spatial_matrix_t[~Scalar], y: Scalar) -> spatial_matrix_t[~Scalar]


.. function:: mul(x: float64, y: spatial_matrix_t[<class 'warp.types.float64'>]) -> spatial_matrix_t[<class 'warp.types.float64'>]


.. function:: mul(x: float16, y: spatial_matrix_t[<class 'warp.types.float16'>]) -> spatial_matrix_t[<class 'warp.types.float16'>]


.. function:: mul(x: float32, y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: mul(x: float32, y: spatial_matrix_t[<class 'warp.types.float32'>]) -> spatial_matrix_t[<class 'warp.types.float32'>]


.. function:: mul(x: Scalar, y: spatial_matrix_t[~Scalar]) -> spatial_matrix_t[~Scalar]


.. function:: mul(x: transform_t[<class 'warp.types.float64'>], y: transform_t[<class 'warp.types.float64'>]) -> transform_t[<class 'warp.types.float64'>]


.. function:: mul(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: mul(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: mul(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: mul(x: transform_t[<class 'warp.types.float32'>], y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: mul(x: transform_t[<class 'warp.types.float16'>], y: transform_t[<class 'warp.types.float16'>]) -> transform_t[<class 'warp.types.float16'>]


.. function:: mul(x: transform_t[~Scalar], y: transform_t[~Scalar]) -> transform_t[~Scalar]


.. function:: mul(x: float64, y: transform_t[<class 'warp.types.float64'>]) -> transform_t[<class 'warp.types.float64'>]


.. function:: mul(x: float16, y: transform_t[<class 'warp.types.float16'>]) -> transform_t[<class 'warp.types.float16'>]


.. function:: mul(x: float32, y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: mul(x: float32, y: transform_t[<class 'warp.types.float32'>]) -> transform_t[<class 'warp.types.float32'>]


.. function:: mul(x: Scalar, y: transform_t[~Scalar]) -> transform_t[~Scalar]


.. function:: mul(x: transform_t[<class 'warp.types.float64'>], y: float64) -> transform_t[<class 'warp.types.float64'>]


.. function:: mul(x: transform_t[<class 'warp.types.float16'>], y: float16) -> transform_t[<class 'warp.types.float16'>]


.. function:: mul(x: transform_t[<class 'warp.types.float32'>], y: float32) -> transform_t[<class 'warp.types.float32'>]


.. function:: mul(x: transform_t[<class 'warp.types.float32'>], y: float32) -> transform_t[<class 'warp.types.float32'>]


.. function:: mul(x: transform_t[~Scalar], y: Scalar) -> transform_t[~Scalar]


.. function:: mod(x: uint32, y: uint32) -> uint32


.. function:: mod(x: int16, y: int16) -> int16


.. function:: mod(x: float64, y: float64) -> float64


.. function:: mod(x: int8, y: int8) -> int8


.. function:: mod(x: float16, y: float16) -> float16


.. function:: mod(x: uint16, y: uint16) -> uint16


.. function:: mod(x: int32, y: int32) -> int32


.. function:: mod(x: uint64, y: uint64) -> uint64


.. function:: mod(x: float32, y: float32) -> float32


.. function:: mod(x: int64, y: int64) -> int64


.. function:: mod(x: uint8, y: uint8) -> uint8


.. function:: mod(x: Scalar, y: Scalar) -> Scalar


.. function:: div(x: uint32, y: uint32) -> uint32


.. function:: div(x: int16, y: int16) -> int16


.. function:: div(x: float64, y: float64) -> float64


.. function:: div(x: int8, y: int8) -> int8


.. function:: div(x: float16, y: float16) -> float16


.. function:: div(x: uint16, y: uint16) -> uint16


.. function:: div(x: int32, y: int32) -> int32


.. function:: div(x: uint64, y: uint64) -> uint64


.. function:: div(x: float32, y: float32) -> float32


.. function:: div(x: int64, y: int64) -> int64


.. function:: div(x: uint8, y: uint8) -> uint8


.. function:: div(x: Scalar, y: Scalar) -> Scalar


.. function:: div(x: vec[2, <class 'warp.types.float64'>], y: float64) -> vec[2, <class 'warp.types.float64'>]


.. function:: div(x: vec[3, <class 'warp.types.float64'>], y: float64) -> vec[3, <class 'warp.types.float64'>]


.. function:: div(x: vec[4, <class 'warp.types.float64'>], y: float64) -> vec[4, <class 'warp.types.float64'>]


.. function:: div(x: vec[2, <class 'warp.types.float16'>], y: float16) -> vec[2, <class 'warp.types.float16'>]


.. function:: div(x: vec[3, <class 'warp.types.float16'>], y: float16) -> vec[3, <class 'warp.types.float16'>]


.. function:: div(x: vec[4, <class 'warp.types.float16'>], y: float16) -> vec[4, <class 'warp.types.float16'>]


.. function:: div(x: vec[2, <class 'warp.types.uint8'>], y: uint8) -> vec[2, <class 'warp.types.uint8'>]


.. function:: div(x: vec[3, <class 'warp.types.uint8'>], y: uint8) -> vec[3, <class 'warp.types.uint8'>]


.. function:: div(x: vec[4, <class 'warp.types.uint8'>], y: uint8) -> vec[4, <class 'warp.types.uint8'>]


.. function:: div(x: vec[2, <class 'warp.types.float32'>], y: float32) -> vec[2, <class 'warp.types.float32'>]


.. function:: div(x: vec[2, <class 'warp.types.float32'>], y: float32) -> vec[2, <class 'warp.types.float32'>]


.. function:: div(x: vec[3, <class 'warp.types.float32'>], y: float32) -> vec[3, <class 'warp.types.float32'>]


.. function:: div(x: vec[3, <class 'warp.types.float32'>], y: float32) -> vec[3, <class 'warp.types.float32'>]


.. function:: div(x: vec[4, <class 'warp.types.float32'>], y: float32) -> vec[4, <class 'warp.types.float32'>]


.. function:: div(x: vec[4, <class 'warp.types.float32'>], y: float32) -> vec[4, <class 'warp.types.float32'>]


.. function:: div(x: vec[typing.Any, ~Scalar], y: Scalar) -> vec[typing.Any, ~Scalar]


.. function:: div(x: mat[2, 2, <class 'warp.types.float64'>], y: float64) -> mat[2, 2, <class 'warp.types.float64'>]


.. function:: div(x: mat[3, 3, <class 'warp.types.float64'>], y: float64) -> mat[3, 3, <class 'warp.types.float64'>]


.. function:: div(x: mat[4, 4, <class 'warp.types.float64'>], y: float64) -> mat[4, 4, <class 'warp.types.float64'>]


.. function:: div(x: mat[2, 2, <class 'warp.types.float16'>], y: float16) -> mat[2, 2, <class 'warp.types.float16'>]


.. function:: div(x: mat[3, 3, <class 'warp.types.float16'>], y: float16) -> mat[3, 3, <class 'warp.types.float16'>]


.. function:: div(x: mat[4, 4, <class 'warp.types.float16'>], y: float16) -> mat[4, 4, <class 'warp.types.float16'>]


.. function:: div(x: mat[2, 2, <class 'warp.types.float32'>], y: float32) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: div(x: mat[2, 2, <class 'warp.types.float32'>], y: float32) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: div(x: mat[3, 3, <class 'warp.types.float32'>], y: float32) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: div(x: mat[3, 3, <class 'warp.types.float32'>], y: float32) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: div(x: mat[4, 4, <class 'warp.types.float32'>], y: float32) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: div(x: mat[4, 4, <class 'warp.types.float32'>], y: float32) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: div(x: mat[typing.Any, typing.Any, ~Scalar], y: Scalar) -> mat[typing.Any, typing.Any, ~Scalar]


.. function:: div(x: quaternion[<class 'warp.types.float64'>], y: float64) -> quaternion[<class 'warp.types.float64'>]


.. function:: div(x: quaternion[<class 'warp.types.float16'>], y: float16) -> quaternion[<class 'warp.types.float16'>]


.. function:: div(x: quaternion[<class 'warp.types.float32'>], y: float32) -> quaternion[<class 'warp.types.float32'>]


.. function:: div(x: quaternion[<class 'warp.types.float32'>], y: float32) -> quaternion[<class 'warp.types.float32'>]


.. function:: div(x: quaternion[~Scalar], y: Scalar) -> quaternion[~Scalar]


.. function:: floordiv(x: uint32, y: uint32) -> uint32


.. function:: floordiv(x: int16, y: int16) -> int16


.. function:: floordiv(x: float64, y: float64) -> float64


.. function:: floordiv(x: int8, y: int8) -> int8


.. function:: floordiv(x: float16, y: float16) -> float16


.. function:: floordiv(x: uint16, y: uint16) -> uint16


.. function:: floordiv(x: int32, y: int32) -> int32


.. function:: floordiv(x: uint64, y: uint64) -> uint64


.. function:: floordiv(x: float32, y: float32) -> float32


.. function:: floordiv(x: int64, y: int64) -> int64


.. function:: floordiv(x: uint8, y: uint8) -> uint8


.. function:: floordiv(x: Scalar, y: Scalar) -> Scalar


.. function:: neg(x: uint32) -> uint32


.. function:: neg(x: int16) -> int16


.. function:: neg(x: float64) -> float64


.. function:: neg(x: int8) -> int8


.. function:: neg(x: float16) -> float16


.. function:: neg(x: uint16) -> uint16


.. function:: neg(x: int32) -> int32


.. function:: neg(x: uint64) -> uint64


.. function:: neg(x: float32) -> float32


.. function:: neg(x: int64) -> int64


.. function:: neg(x: uint8) -> uint8


.. function:: neg(x: Scalar) -> Scalar


.. function:: neg(x: vec[2, <class 'warp.types.float64'>]) -> vec[2, <class 'warp.types.float64'>]


.. function:: neg(x: vec[3, <class 'warp.types.float64'>]) -> vec[3, <class 'warp.types.float64'>]


.. function:: neg(x: vec[4, <class 'warp.types.float64'>]) -> vec[4, <class 'warp.types.float64'>]


.. function:: neg(x: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: neg(x: vec[2, <class 'warp.types.float32'>]) -> vec[2, <class 'warp.types.float32'>]


.. function:: neg(x: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: neg(x: vec[3, <class 'warp.types.float32'>]) -> vec[3, <class 'warp.types.float32'>]


.. function:: neg(x: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: neg(x: vec[4, <class 'warp.types.float32'>]) -> vec[4, <class 'warp.types.float32'>]


.. function:: neg(x: vec[2, <class 'warp.types.uint8'>]) -> vec[2, <class 'warp.types.uint8'>]


.. function:: neg(x: vec[3, <class 'warp.types.uint8'>]) -> vec[3, <class 'warp.types.uint8'>]


.. function:: neg(x: vec[4, <class 'warp.types.uint8'>]) -> vec[4, <class 'warp.types.uint8'>]


.. function:: neg(x: vec[2, <class 'warp.types.float16'>]) -> vec[2, <class 'warp.types.float16'>]


.. function:: neg(x: vec[3, <class 'warp.types.float16'>]) -> vec[3, <class 'warp.types.float16'>]


.. function:: neg(x: vec[4, <class 'warp.types.float16'>]) -> vec[4, <class 'warp.types.float16'>]


.. function:: neg(x: vec[typing.Any, ~Scalar]) -> vec[typing.Any, ~Scalar]


.. function:: neg(x: quaternion[<class 'warp.types.float64'>]) -> quaternion[<class 'warp.types.float64'>]


.. function:: neg(x: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: neg(x: quaternion[<class 'warp.types.float32'>]) -> quaternion[<class 'warp.types.float32'>]


.. function:: neg(x: quaternion[<class 'warp.types.float16'>]) -> quaternion[<class 'warp.types.float16'>]


.. function:: neg(x: quaternion[~Scalar]) -> quaternion[~Scalar]


.. function:: neg(x: mat[2, 2, <class 'warp.types.float64'>]) -> mat[2, 2, <class 'warp.types.float64'>]


.. function:: neg(x: mat[3, 3, <class 'warp.types.float64'>]) -> mat[3, 3, <class 'warp.types.float64'>]


.. function:: neg(x: mat[4, 4, <class 'warp.types.float64'>]) -> mat[4, 4, <class 'warp.types.float64'>]


.. function:: neg(x: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: neg(x: mat[2, 2, <class 'warp.types.float32'>]) -> mat[2, 2, <class 'warp.types.float32'>]


.. function:: neg(x: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: neg(x: mat[3, 3, <class 'warp.types.float32'>]) -> mat[3, 3, <class 'warp.types.float32'>]


.. function:: neg(x: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: neg(x: mat[4, 4, <class 'warp.types.float32'>]) -> mat[4, 4, <class 'warp.types.float32'>]


.. function:: neg(x: mat[2, 2, <class 'warp.types.float16'>]) -> mat[2, 2, <class 'warp.types.float16'>]


.. function:: neg(x: mat[3, 3, <class 'warp.types.float16'>]) -> mat[3, 3, <class 'warp.types.float16'>]


.. function:: neg(x: mat[4, 4, <class 'warp.types.float16'>]) -> mat[4, 4, <class 'warp.types.float16'>]


.. function:: neg(x: mat[typing.Any, typing.Any, ~Scalar]) -> mat[typing.Any, typing.Any, ~Scalar]


.. function:: unot(b: bool) -> bool


.. rubric:: Footnotes
.. [1] Note: function gradients not implemented for backpropagation.
